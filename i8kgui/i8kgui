#!/usr/bin/env python3
#  Copyright (c) 2022, Dr Rahim Lakhoo, razman786@gmail.com.
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not,
# see <https://www.gnu.org/licenses/>.
#
import shutil
from pathlib import Path

from PySide6 import QtCore
from PySide6.QtCore import QSize, Slot, QSettings, QProcess
from PySide6.QtGui import QIcon, QAction, QScreen, Qt, QIntValidator, QPalette, QColor, QActionGroup
from PySide6.QtWidgets import QApplication, QMainWindow, QSystemTrayIcon, QMenu, QMessageBox, QDialog, QPushButton, \
    QCheckBox, QLineEdit, QLabel, QFormLayout


class I8kGui(QMainWindow):
    def __init__(self):
        super(I8kGui, self).__init__()
        self.settings = QSettings()
        self.critical_error = False
        self.degree_sign = u'\N{DEGREE SIGN}'
        self.p_state = None
        self.p = None
        self.smbios_data = []
        self.smbios_info = dict()
        self.supported_thermal_modes_data = []
        self.supported_thermal_modes = []
        self.current_thermal_mode_data = []
        self.current_thermal_mode = None
        self.always_on = False
        self.bios_thermal_control_on = False
        self.tray_menu = QMenu()
        self.thermal_menu_group = QActionGroup(self.tray_menu)
        self.thermal_control_menu = QMenu("I8K Thermal Management")
        self.monitor_interval = 1000
        self.always_on_checkbox = QCheckBox()
        self.thermal_checkbox = QCheckBox()
        self.interval_input = QLineEdit()
        self.settings_dialog = QDialog()
        self.info_dialog = QDialog()
        self.save_button = QPushButton("Save", self.settings_dialog)
        self.smbios_button = QPushButton("SMBIOS Information", self.info_dialog)
        self.i8k_format_version = QLabel("1")
        self.bios_version = QLabel("1")
        self.service_tag = QLabel("N/A")
        self.power_status = QLabel("N/A")
        self.button_status = QLabel("N/A")
        self.fan_mode_menu_item = QAction("", checkable=False)
        self.left_fan_thermal_menu_item = QAction("", checkable=False)
        self.right_fan_thermal_menu_item = QAction("", checkable=False)
        self.left_fan_mode = 0
        self.right_fan_mode = 0
        self.i8k_info = dict()
        self.load_settings()
        self.monitorTimer = QtCore.QTimer(self)
        self.monitorTimer.timeout.connect(self.refresh_monitor)
        self.monitorTimer.setInterval(self.monitor_interval)
        self.create_settings_dialog()
        self.create_info_dialog()
        self.tray = None
        self.first_load = True
        self.cpu_mhz = QAction("CPU MHz:                ")
        self.cpu_temp = QAction("CPU Temp:                ")
        self.left_fan_rpm = QAction("Left Fan RPM:          ")
        self.right_fan_rpm = QAction("Right Fan RPM:       ")
        self.left_fan_status = QAction("Left Fan Status:      ")
        self.right_fan_status = QAction("Right Fan Status:   ")
        self.load_sys_tray()

    def close_app(self):
        self.save_settings()
        app.quit()

    def load_settings(self):
        # load continuous data collection setting
        always_on = self.settings.value('always_on')
        if always_on and always_on.lower() == 'true':
            self.always_on = True
            self.always_on_checkbox.setCheckState(Qt.Checked)
        else:
            self.always_on = False
            self.always_on_checkbox.setCheckState(Qt.Unchecked)

        # load monitoring interval setting
        self.monitor_interval = int(self.settings.value('interval', 1000))

        # load smbios information from config
        info = list(self.settings.value('smbios', []))
        if info:
            # reconstruct list back into dict preserving order
            self.smbios_info = {info[i][0]: info[i][1] for i in range(0, len(info))}  # convert data to dict
            self.smbios_button.setDisabled(True)

        # load supported thermal modes setting
        supported_thermal_modes = self.settings.value('supported_thermal_modes')
        if supported_thermal_modes is None:
            self.supported_thermal_modes = []
        else:
            self.supported_thermal_modes = list(supported_thermal_modes)

        # load thermal mode settings
        bios_thermal_control_on = self.settings.value('bios_thermal_control_on')
        if bios_thermal_control_on is not None:
            if bios_thermal_control_on.lower() == 'true':
                self.bios_thermal_control_on = True
                self.current_thermal_mode = self.settings.value('current_thermal_mode')
                self.thermal_checkbox.setChecked(True)
                self.thermal_control_menu.setTitle("BIOS Thermal Management")
            else:
                self.bios_thermal_control_on = False
                self.thermal_control_menu.setTitle("I8K Thermal Management")
        else:
            self.bios_thermal_control_on = False
            self.thermal_control_menu.setTitle("I8K Thermal Management")

        self.build_thermal_menu()

    def save_settings(self):
        self.settings.setValue('current_thermal_mode', self.current_thermal_mode)
        self.settings.setValue('supported_thermal_modes', self.supported_thermal_modes)
        self.settings.setValue('bios_thermal_control_on', self.bios_thermal_control_on)
        self.settings.setValue('always_on', self.always_on)
        self.settings.setValue('interval', self.monitor_interval)
        if self.smbios_info:
            # preserve ordering by storing a list
            self.settings.setValue('smbios', list(self.smbios_info.items()))

    def enable_thermal_control(self, checked):
        if checked == Qt.Checked:
            self.bios_thermal_control(op='enable')
        else:
            self.bios_thermal_control(op='disable')

    def always_collect(self, checked):
        if checked == Qt.Checked:
            self.monitor_interval = int(self.interval_input.text())
            self.monitorTimer.setInterval(self.monitor_interval)
            self.always_on = True
            if not self.monitorTimer.isActive():
                self.monitorTimer.start()
            else:
                self.monitorTimer.stop()
                self.monitorTimer.start()
        else:
            self.always_on = False
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()

    def save_dialog_settings(self):
        if self.monitor_interval != int(self.interval_input.text()):
            self.monitor_interval = int(self.interval_input.text())
            self.monitorTimer.setInterval(self.monitor_interval)
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()
                self.monitorTimer.start()
        self.save_settings()
        self.settings_dialog.close()

    def close_info_dialog(self):
        self.save_settings()
        self.info_dialog.close()

    def smbios_message(self, msg):
        split_msg = msg.split(': ')
        for item in split_msg:
            split_item = item.split('\n')
            for part_item in split_item:
                self.smbios_data.append(part_item.strip())

    def bios_thermal_control(self, op=None):
        if self.p is None:
            # find smbios script
            thermal_file = Path(str(shutil.which("i8kgui_thermal_control")))
            if not thermal_file.is_file():
                thermal_file = Path("i8kgui_thermal_control")
            if op == 'enable':
                self.p = QProcess()  # Keep a reference to the QProcess (e.g. on self) while it's running.
                self.p.readyReadStandardOutput.connect(self.handle_thermal_stdout)
                self.p.readyReadStandardError.connect(self.handle_thermal_stderr)
                self.p.stateChanged.connect(self.handle_process_state)
                self.p.finished.connect(self.thermal_process_finished)  # Clean up once complete.
                self.p.start("pkexec", [str(thermal_file.resolve()), '--enable'])
            elif op == 'disable':
                self.p = QProcess()  # Keep a reference to the QProcess (e.g. on self) while it's running.
                self.p.readyReadStandardOutput.connect(self.handle_thermal_stdout)
                self.p.readyReadStandardError.connect(self.handle_thermal_stderr)
                self.p.stateChanged.connect(self.handle_process_state)
                self.p.finished.connect(self.thermal_process_disable_finished)  # Clean up once complete.
                self.p.start("pkexec", [str(thermal_file.resolve()), '--disable'])
        else:
            return False

    def handle_thermal_stderr(self):
        data = self.p.readAllStandardError()
        stderr = bytes(data).decode("utf8")
        print(f"QProcess error {stderr}")

    def handle_thermal_stdout(self):
        data = self.p.readAllStandardOutput()
        stdout = bytes(data).decode("utf8")
        if stdout.startswith('Supported Thermal Modes'):
            split_stdout = stdout.split('\n')
            for item in split_stdout:
                self.supported_thermal_modes_data.append(item.strip())
        if stdout.startswith('Current Thermal Modes'):
            split_stdout = stdout.split('\n')
            for item in split_stdout:
                self.current_thermal_mode_data.append(item.strip())
        if stdout.startswith('Helper function to Set Thermal Mode'):
            split_stdout = stdout.split(': ')
            self.current_thermal_mode = split_stdout[1].strip().title().replace("-", " ")

    def thermal_process_finished(self):
        if self.p.exitCode() != 0:
            self.p = None
            self.thermal_checkbox.setChecked(False)
            self.bios_thermal_control_on = False
            self.supported_thermal_modes_data = []
            self.current_thermal_mode_data = []
            return
        else:
            self.p = None
        if self.supported_thermal_modes_data:
            self.supported_thermal_modes_data.pop(0)
            self.supported_thermal_modes_data.pop()
            self.supported_thermal_modes = self.supported_thermal_modes_data
            self.supported_thermal_modes_data = []
        if self.current_thermal_mode_data:
            self.current_thermal_mode = self.current_thermal_mode_data[1].title().replace("-", " ")
            self.current_thermal_mode_data = []
        print(f"supported modes: {self.supported_thermal_modes}")
        print(f"current mode {self.current_thermal_mode}")
        if self.thermal_checkbox.isChecked() and self.current_thermal_mode is not None:
            self.bios_thermal_control_on = True
            self.switch_thermal_menu()
        else:
            self.bios_thermal_control_on = False
            self.switch_thermal_menu()

    def thermal_process_disable_finished(self):
        if self.p.exitCode() != 0:
            self.p = None
            self.thermal_checkbox.setChecked(True)
            self.bios_thermal_control_on = True
            self.supported_thermal_modes_data = []
            self.current_thermal_mode_data = []
            return
        else:
            self.p = None
        if self.supported_thermal_modes_data:
            self.supported_thermal_modes_data.pop(0)
            self.supported_thermal_modes_data.pop()
            self.supported_thermal_modes = self.supported_thermal_modes_data
            self.supported_thermal_modes_data = []
        if self.current_thermal_mode_data:
            self.current_thermal_mode = self.current_thermal_mode_data[1].title().replace("-", " ")
            self.current_thermal_mode_data = []
        print(f"disable supported modes: {self.supported_thermal_modes}")
        print(f"disable current mode {self.current_thermal_mode}")
        if self.thermal_checkbox.isChecked() and self.current_thermal_mode is not None:
            self.bios_thermal_control_on = True
            self.switch_thermal_menu()
        else:
            self.bios_thermal_control_on = False
            self.switch_thermal_menu()

    def switch_thermal_menu(self):
        # remove and re-build thermal menu
        self.remove_thermal_menu()
        self.build_thermal_menu()

    def remove_thermal_menu(self):
        actions = self.thermal_menu_group.actions()
        for action in actions:
            self.thermal_control_menu.removeAction(action)
            self.thermal_menu_group.removeAction(action)

        self.thermal_menu_group.setEnabled(False)

    def build_thermal_menu(self):
        if not self.thermal_menu_group.actions():
            if self.bios_thermal_control_on:
                if self.supported_thermal_modes:
                    for item in self.supported_thermal_modes:
                        thermal_menu_item = QAction(item, checkable=True)
                        self.thermal_control_menu.addAction(thermal_menu_item)
                        self.thermal_menu_group.addAction(thermal_menu_item)

                    self.thermal_menu_group.setEnabled(True)
                    self.thermal_control_menu.setTitle("BIOS Thermal Management")
                    actions = self.thermal_menu_group.actions()
                    for action in actions:
                        if action.text() == self.current_thermal_mode:
                            action.setChecked(True)
            elif not self.bios_thermal_control_on:
                self.i8k_info = self.get_i8k_information()
                print(f'info {self.i8k_info}')
                if self.i8k_info:
                    for key, value in self.i8k_info.items():
                        if key.startswith('Fan Mode'):
                            mode = key.split('Fan Mode ')
                            if int(mode[1]) == self.left_fan_mode:
                                title = f"{key}: Low: {value[0]}{self.degree_sign}C  High: {value[1]}{self.degree_sign}C"
                                self.fan_mode_menu_item.setText(title)
                                self.thermal_control_menu.addAction(self.fan_mode_menu_item)
                                self.thermal_menu_group.addAction(self.fan_mode_menu_item)
                        elif key.startswith('Left Speed'):
                            title = f"Max {key}: {value[self.left_fan_mode]}"
                            self.left_fan_thermal_menu_item.setText(title)
                            self.thermal_control_menu.addAction(self.left_fan_thermal_menu_item)
                            self.thermal_menu_group.addAction(self.left_fan_thermal_menu_item)
                        elif key.startswith('Right Speed'):
                            title = f"Max {key}: {value[self.right_fan_mode]}"
                            self.right_fan_thermal_menu_item.setText(title)
                            self.thermal_control_menu.addAction(self.right_fan_thermal_menu_item)
                            self.thermal_menu_group.addAction(self.right_fan_thermal_menu_item)
                        else:
                            title = f"{key}: {value}{self.degree_sign}C"
                            thermal_menu_item = QAction(title, checkable=False)
                            self.thermal_control_menu.addAction(thermal_menu_item)
                            self.thermal_menu_group.addAction(thermal_menu_item)

                    self.thermal_menu_group.setEnabled(True)
                    self.thermal_control_menu.setTitle("I8K Thermal Management")

    def get_i8k_information(self):
        if not self.critical_error:
            info = dict()
            try:
                i8k_config = open('/etc/i8kmon.conf', 'r')
            except IOError as e:
                self.critical_error = True
                self.tray.showMessage("i8kgui",
                                      f"Error cannot find /etc/i8kmon.conf. Please check your config file \n\n{e}",
                                      icon=QSystemTrayIcon.Critical, msecs=10000)
            else:
                for line in i8k_config:
                    if line.startswith(f'set config(t_high)'):
                        conf = line.split('set config(t_high)')[1].strip()
                        info['High CPU Temp'] = conf
                    if line.startswith(f'set config(0)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 0'] = list(conf[1].split())
                    if line.startswith(f'set config(1)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 1'] = list(conf[1].split())
                    if line.startswith(f'set config(2)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 2'] = list(conf[1].split())
                    if line.startswith(f'set config(3)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 3'] = list(conf[1].split())
                    if line.startswith('set status(leftspeed)'):
                        conf = line.split("set status(leftspeed)")[1].strip().strip('"')
                        info['Left Speed'] = list(conf.split())
                    if line.startswith('set status(rightspeed)'):
                        conf = line.split("set status(rightspeed)")[1].strip().strip('"')
                        info['Right Speed'] = list(conf.split())
                i8k_config.close()
            return info

    def get_smbios_information(self):
        if self.p is None:
            # find smbios script
            smbios_file = Path(str(shutil.which("smbios-sys-info")))
            if not smbios_file.is_file():
                self.tray.showMessage("i8kgui",
                                      f"Error please install python3-libsmbios, smbios-sys-info not found",
                                      icon=QSystemTrayIcon.Critical, msecs=10000)
                return

            # self.smbios_message("Executing process")
            self.p = QProcess()  # Keep a reference to the QProcess (e.g. on self) while it's running.
            self.p.readyReadStandardOutput.connect(self.handle_smbios_stdout)
            self.p.readyReadStandardError.connect(self.handle_smbios_stderr)
            self.p.stateChanged.connect(self.handle_process_state)
            self.p.finished.connect(self.smbios_process_finished)  # Clean up once complete.
            self.p.start("pkexec", [str(smbios_file.resolve())])

    def handle_smbios_stderr(self):
        data = self.p.readAllStandardError()
        stderr = bytes(data).decode("utf8")
        print(f"QProcess error {stderr}")

    def handle_smbios_stdout(self):
        data = self.p.readAllStandardOutput()
        stdout = bytes(data).decode("utf8")
        self.smbios_message(stdout)

    def handle_process_state(self, state):
        states = {
            QProcess.NotRunning: 'NotRunning',
            QProcess.Starting: 'Starting',
            QProcess.Running: 'Running',
        }
        self.p_state = states[state]

    def smbios_process_finished(self):
        self.p = None
        self.process_smbios_data()

    def process_smbios_data(self):
        if self.smbios_data:
            self.smbios_data.pop()  # remove white space
            self.smbios_info = {self.smbios_data[i]: self.smbios_data[i + 1] for i in
                                range(0, len(self.smbios_data), 2)}  # convert data to dict
            self.smbios_data = []  # empty data container
            f_layout = self.info_dialog.layout()
            for key, value in self.smbios_info.items():
                f_layout.insertRow(f_layout.rowCount() - 2, str(key), QLabel(str(value)))
            self.smbios_button.setDisabled(True)

    def create_info_dialog(self):
        close_button = QPushButton("close", self.info_dialog)
        close_button.setMaximumWidth(100)
        close_button.clicked.connect(self.close_info_dialog)

        self.smbios_button.setMaximumWidth(250)
        self.smbios_button.clicked.connect(self.get_smbios_information)

        f_layout = QFormLayout()
        f_layout.addRow("i8k Format Version", self.i8k_format_version)
        f_layout.addRow("BIOS Version", self.bios_version)
        f_layout.addRow("Service Tag", self.service_tag)
        f_layout.addRow("A/C Power Supply", self.power_status)
        f_layout.addRow("Button Status", self.button_status)
        f_layout.addRow(" ", None)
        f_layout.addRow("(requires password)", self.smbios_button)
        f_layout.addRow(" ", None)
        f_layout.addRow(" ", None)
        f_layout.addWidget(close_button)
        if self.smbios_info:
            for key, value in self.smbios_info.items():
                f_layout.insertRow(f_layout.rowCount() - 2, str(key), QLabel(str(value)))
        self.info_dialog.setLayout(f_layout)

        # set dialog geometry
        self.info_dialog.setWindowTitle("Information")
        self.info_dialog.setWindowModality(QtCore.Qt.ApplicationModal)
        self.info_dialog.setMinimumWidth(450)
        self.info_dialog.setMaximumWidth(600)
        self.info_dialog.setMaximumHeight(600)
        center_point = QScreen.availableGeometry(QApplication.primaryScreen()).center()
        fg = self.info_dialog.frameGeometry()
        fg.moveCenter(center_point)
        self.info_dialog.move(fg.topLeft())

    def create_settings_dialog(self):
        self.save_button.setMaximumWidth(100)
        self.always_on_checkbox.setText("Collect statistics continuously")
        self.always_on_checkbox.stateChanged.connect(self.always_collect)
        self.thermal_checkbox.setText("Enable BIOS thermal management")
        self.thermal_checkbox.stateChanged.connect(self.enable_thermal_control)
        self.interval_input.setValidator(QIntValidator())
        self.interval_input.setMaxLength(6)
        self.interval_input.setText(str(self.monitor_interval))

        self.save_button.clicked.connect(self.save_dialog_settings)
        f_layout = QFormLayout()
        f_layout.addRow("(requires password)", self.thermal_checkbox)
        f_layout.addRow(" ", self.always_on_checkbox)
        f_layout.addRow(" ", None)
        f_layout.addRow("Monitoring Interval (milliseconds):", self.interval_input)
        f_layout.addRow(" ", None)
        f_layout.addRow(self.save_button)
        self.settings_dialog.setLayout(f_layout)

        # set dialog geometry
        self.settings_dialog.setWindowTitle("Settings")
        self.settings_dialog.setWindowModality(QtCore.Qt.ApplicationModal)
        self.settings_dialog.setMaximumWidth(400)
        self.settings_dialog.setMaximumHeight(400)
        center_point = QScreen.availableGeometry(QApplication.primaryScreen()).center()
        fg = self.settings_dialog.frameGeometry()
        fg.moveCenter(center_point)
        self.settings_dialog.move(fg.topLeft())

    def load_sys_tray(self):
        self.tray = QSystemTrayIcon(self)
        if self.tray.isSystemTrayAvailable():
            icon = QIcon(str(Path.home()) + "/.local/share/icons/i8kgui_icon.png")
            if icon.pixmap(QSize(64, 64)).isNull():
                icon = QIcon('icons/i8kgui_icon.png')
            self.tray.setIcon(icon)
            self.tray.activated.connect(self.status)
            self.tray.messageClicked.connect(self.message_clicked)

            # workaround because tray activated only works with double click
            self.tray_menu.aboutToShow.connect(self.monitor)
            self.tray_menu.aboutToHide.connect(self.stop_monitor)

            # setup display
            self.tray_menu.addAction(self.cpu_mhz)
            self.tray_menu.addAction(self.cpu_temp)
            self.tray_menu.addAction(self.left_fan_rpm)
            self.tray_menu.addAction(self.right_fan_rpm)
            self.tray_menu.addAction(self.left_fan_status)
            self.tray_menu.addAction(self.right_fan_status)
            self.tray_menu.addSeparator()

            # setup thermal control management menu
            self.tray_menu.addMenu(self.thermal_control_menu)
            self.thermal_menu_group.setExclusive(True)
            self.thermal_menu_group.triggered.connect(self.thermal_mode_selection)
            self.build_thermal_menu()  # menu created based on settings
            self.tray_menu.addSeparator()

            # add info, settings and quit menu items
            action_info = self.tray_menu.addAction("Information")
            action_info.triggered.connect(self.show_info)
            action_settings = self.tray_menu.addAction("Settings")
            action_settings.triggered.connect(self.show_settings)
            action_quit = self.tray_menu.addAction("Quit")
            action_quit.triggered.connect(self.close_app)

            self.tray.setContextMenu(self.tray_menu)
            self.tray.setToolTip("i8kgui")
            self.tray.setVisible(True)
        else:
            QMessageBox.critical(None, "i8kgui", "Unable to locate system tray on this system.")
            self.close_app()

    def thermal_mode_selection(self, checked):
        if self.bios_thermal_control_on:
            if self.p is None:
                # find libsmbios script
                thermal_file = Path(str(shutil.which("smbios-thermal-ctl")))
                if not thermal_file.is_file():
                    self.tray.showMessage("i8kgui",
                                          f"Error please install python3-libsmbios, smbios-thermal-ctl not found.",
                                          icon=QSystemTrayIcon.Critical, msecs=10000)
                    return

                t_args = "--set-thermal-mode="
                if checked.text() == 'Quiet':
                    t_args = t_args + "quiet"
                elif checked.text() == 'Cool Bottom':
                    t_args = t_args + "cool-bottom"
                elif checked.text() == 'Balanced':
                    t_args = t_args + "balanced"
                elif checked.text() == 'Performance':
                    t_args = t_args + "performance"
                else:
                    t_args = t_args + 'balanced'
                self.p = QProcess()  # Keep a reference to the QProcess (e.g. on self) while it's running.
                self.p.readyReadStandardOutput.connect(self.handle_thermal_stdout)
                self.p.readyReadStandardError.connect(self.handle_thermal_stderr)
                self.p.stateChanged.connect(self.handle_process_state)
                self.p.finished.connect(self.thermal_process_finished)  # Clean up once complete.
                self.p.start("pkexec", [str(thermal_file.resolve()), t_args])
        else:
            print("Edit i8kmon config")  # TODO - add i8kmon config updating

    @Slot()
    def message_clicked(self):
        self.close_app()

    def read_proc(self):
        # read i8k values from /proc then update the system tray
        # and send a fake click to initiate live updating while
        # the system tray is in active use.
        if not self.critical_error:
            try:
                i8k_proc = open('/proc/i8k', 'r')
            except IOError as e:
                self.critical_error = True
                self.tray.showMessage("i8kgui", f"Error cannot find i8k module. Please install/start i8kutils.\n\n{e}",
                                      icon=QSystemTrayIcon.Critical, msecs=10000)
            else:
                line = i8k_proc.readline()  # output is only a single line.
                i8k_proc.close()
                split_line = line.split(' ')
                self.cpu_temp.setText(f"CPU Temp:                {split_line[3].strip()}{self.degree_sign}C")
                self.left_fan_rpm.setText(f"Left Fan RPM:          {split_line[6].strip()}")
                self.right_fan_rpm.setText(f"Right Fan RPM:       {split_line[7].strip()}")
                self.left_fan_status.setText(f"Left Fan Status:      {split_line[4].strip()}")
                self.right_fan_status.setText(f"Right Fan Status:   {split_line[5].strip()}")
                if self.left_fan_mode != int(split_line[4].strip()) or self.right_fan_mode != int(
                        split_line[5].strip()):
                    self.left_fan_mode = int(split_line[4].strip())
                    self.right_fan_mode = int(split_line[5].strip())
                    self.update_i8k_thermal()

                self.i8k_format_version.setText(split_line[0].strip())
                self.bios_version.setText(split_line[1].strip())
                self.service_tag.setText(split_line[2].strip())
                self.power_status.setText(split_line[8].strip())
                self.button_status.setText(split_line[9].strip())

                """try:
                    cpu_proc = open('/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq', 'r')
                except IOError as e:
                    self.critical_error = True
                    self.tray.showMessage("i8kgui", f"Error cannot find /proc/cpuinfo.\n\n{e}",
                                          icon=QSystemTrayIcon.Critical, msecs=10000)
                else:
                    line = cpu_proc.readline()  # output is only a single line.
                    cpu_proc.close()
                    mhz = int(line.strip('\n').strip())/1000
                    self.cpu_mhz.setText(f"CPU Freq:                  {int(mhz)} MHz")"""
                try:
                    cpu_proc = open('/proc/cpuinfo', 'r')
                except IOError as e:
                    self.critical_error = True
                    self.tray.showMessage("i8kgui", f"Error cannot find /proc/cpuinfo.\n\n{e}",
                                          icon=QSystemTrayIcon.Critical, msecs=10000)
                else:
                    all_mhz = []
                    for line in cpu_proc:
                        if 'MHz' in line:
                            mhz = int(line.split(':')[1].strip('\n').split('.')[0].strip())
                            all_mhz.append(mhz)

                    total_mhz = 0
                    for m in all_mhz:
                        total_mhz = total_mhz + m
                    mhz = int(total_mhz / len(all_mhz))
                    self.cpu_mhz.setText(f"CPU Freq:                  {mhz} MHz")
                    cpu_proc.close()

                self.tray.activated.emit(QSystemTrayIcon.Trigger)  # send fake single-click event as workaround

    def update_i8k_thermal(self):
        if not self.i8k_info:
            self.i8k_info = self.get_i8k_information()
        if self.i8k_info:
            for key, value in self.i8k_info.items():
                if key.startswith('Fan Mode'):
                    mode = key.split('Fan Mode ')
                    if int(mode[1]) == self.left_fan_mode:
                        title = f"{key}: Low: {value[0]}{self.degree_sign}C  High: {value[1]}{self.degree_sign}C"
                        self.fan_mode_menu_item.setText(title)
                elif key.startswith('Left Speed'):
                    title = f"Max {key}: {value[self.left_fan_mode]}"
                    self.left_fan_thermal_menu_item.setText(title)
                elif key.startswith('Right Speed'):
                    title = f"Max {key}: {value[self.right_fan_mode]}"
                    self.right_fan_thermal_menu_item.setText(title)

    def status(self, reason):
        # start live updating of values if system tray is in active use,
        # and employ workaround for timer being started upon load.
        if reason == QSystemTrayIcon.ActivationReason.Trigger:
            if not self.monitorTimer.isActive():
                if not self.first_load:
                    self.monitorTimer.start()
                else:
                    self.first_load = False  # workaround to not start QTimer when tray is loaded first time

    def monitor(self):
        self.read_proc()

    def refresh_monitor(self):
        self.read_proc()

    def stop_monitor(self):
        if not self.always_on:
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()

    def show_settings(self):
        if self.settings_dialog.isVisible():
            self.settings_dialog.raise_()
            self.settings_dialog.setFocus()
        else:
            self.settings_dialog.show()
            self.settings_dialog.raise_()
            self.settings_dialog.setFocus()

    def show_info(self):
        if self.info_dialog.isVisible():
            self.info_dialog.raise_()
            self.info_dialog.setFocus()
        else:
            self.info_dialog.show()
            self.info_dialog.raise_()
            self.info_dialog.setFocus()


if __name__ == '__main__':
    app = QApplication([])
    app.setOrganizationName("i8kgui")
    app.setApplicationName("i8kgui")
    app.setApplicationVersion("0.2")

    # setup Dark Mode QPalette - initial setup
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Light, QColor(68, 68, 68))
    palette.setColor(QPalette.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ToolTipBase, Qt.white)
    palette.setColor(QPalette.ToolTipText, Qt.black)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218, 192))
    palette.setColor(QPalette.HighlightedText, Qt.white)

    # setup Dark Mode disabled QPalette
    palette.setColor(QPalette.Disabled, QPalette.Window, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.WindowText, QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.Base, QColor(68, 68, 68))
    palette.setColor(QPalette.Disabled, QPalette.Text, QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.Button, QColor(53, 53, 53, 128))
    palette.setColor(QPalette.Disabled, QPalette.ButtonText, QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.BrightText, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.Link, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.Highlight, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.HighlightedText, Qt.black)

    # add Dark Mode to i8kgui
    app.setPalette(palette)

    app.setQuitOnLastWindowClosed(False)
    tray = I8kGui()

    app.exec()
