#!/usr/bin/env python3
# Copyright (c) 2022-2023, Dr Rahim Lakhoo, razman786@gmail.com.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.
#
from pathlib import Path
import os
import glob
import shutil
import warnings

from PySide6 import QtCore
from PySide6.QtCore import QProcess, QSettings, QSize, Slot, QTimer
from PySide6.QtGui import (QAction, QActionGroup, QColor, QIcon, QIntValidator,
                           QPalette, QScreen, Qt)
from PySide6.QtWidgets import (QApplication, QCheckBox, QDialog, QFormLayout,
                               QLabel, QLineEdit, QMainWindow, QMenu,
                               QMessageBox, QPushButton, QSystemTrayIcon)
import cpuinfo
import psutil

warnings.filterwarnings("ignore")


class I8kGui(QMainWindow):
    """I8kGui."""

    def __init__(self):
        """__init__."""
        super(I8kGui, self).__init__()
        self.settings = QSettings()
        self.critical_error = False
        self.ac_power_supply_on = None
        self.power_sysfs = None
        self.scaling_sysfs = None
        self.tdp = None
        self.ht_sysfs = None
        self.num_phy_cores = psutil.cpu_count(logical=False)
        self.coretemps_sysfs = []
        # check dependencies
        self.check_prerequisites()
        self.degree_sign = u'\N{DEGREE SIGN}'
        self.use_cpu_ave_freq = False
        self.thermal_modes = {}
        self.p_state = None
        self.p = None
        self.smbios_data = []
        self.smbios_info = {}
        self.supported_thermal_modes_data = []
        self.supported_thermal_modes = []
        self.current_thermal_mode_data = []
        self.current_thermal_mode = None
        self.always_on = False
        self.bios_thermal_control_on = False
        self.tray_menu = QMenu()
        self.alternative_cpu_temp = False
        self.thermal_menu_group = QActionGroup(self.tray_menu)
        self.thermal_control_menu = QMenu("I8K Thermal Management")
        self.monitor_interval = 1000
        self.always_on_checkbox = QCheckBox()
        self.thermal_checkbox = QCheckBox()
        self.cpu_ave_freq_checkbox = QCheckBox()
        self.interval_input = QLineEdit()
        self.settings_dialog = QDialog()
        self.info_dialog = QDialog()
        self.save_button = QPushButton("Save", self.settings_dialog)
        self.smbios_button = QPushButton("SMBIOS Information",
                                         self.info_dialog)
        self.cpu_model = QLabel(cpuinfo.get_cpu_info()['brand_raw'])
        self.cpu_tdp = QLabel("N/A")
        self.i8k_format_version = QLabel("1")
        self.bios_version = QLabel("1")
        self.service_tag = QLabel("N/A")
        self.power_status = QLabel("N/A")
        self.button_status = QLabel("N/A")
        self.fan_mode_menu_item = QAction("")
        self.fan_mode_menu_item.setCheckable(False)
        self.left_fan_thermal_menu_item = QAction("")
        self.left_fan_thermal_menu_item.setCheckable(False)
        self.right_fan_thermal_menu_item = QAction("")
        self.right_fan_thermal_menu_item.setCheckable(False)
        self.left_fan_mode = 0
        self.right_fan_mode = 0
        self.i8k_info = {}
        self.load_settings()
        self.monitorTimer = QTimer(self)
        self.monitorTimer.timeout.connect(self.refresh_monitor)
        self.monitorTimer.setInterval(self.monitor_interval)
        self.create_settings_dialog()
        self.create_info_dialog()
        self.tray = None
        self.first_load = True
        self.cpu_temp_sensors = []
        self.cpu_num = psutil.cpu_count()
        self.cpu_sysfs_siblings = []
        self.cpu_siblings = {}
        self.detect_cpu()
        self.cpu_usage = QAction("CPU Usage:\t")
        self.cpu_mhz = QAction("CPU MHz:\t")
        self.cpu_details = QMenu("Per CPU Core\t")
        self.cpu_freq_list = []
        self.cpu_curr_freqs = []
        self.build_cpu_menu()
        self.cpu_governor = QAction("CPU Governor:\t")
        self.cpu_temp = QAction("CPU Temp:\t")
        self.left_fan_rpm = QAction("Left Fan RPM:\t")
        self.right_fan_rpm = QAction("Right Fan RPM:\t")
        self.left_fan_status = QAction("Left Fan Mode:\t")
        self.right_fan_status = QAction("Right Fan Mode:\t")
        self.load_sys_tray()

    def close_app(self):
        """close_app."""
        self.save_settings()
        app.quit()

    def thermal_error_dialog(
        self,
        cmd='disable',
        msg="Critical Service Error. "
            "Please click 'OK' and enter your password if asked."):
        """thermal_error_dialog.

        :param cmd:
        :param msg:
        """
        # displays an error dialog when services are out of sync
        error_dialog = QMessageBox(QMessageBox.Icon.Critical, "i8kgui", msg)
        error_dialog.setText(msg)
        button = error_dialog.exec()
        if button == QMessageBox.Ok:
            # disable bios thermal control (i.e. default is i8kmon)
            self.bios_thermal_control(op=cmd)

    def detect_cpu(self):
        """detect_cpu - find out if HT enabled, create a CPU sibling list and a CPU
        temperature sensor list
        """
        # check if hyperthreading is enabled
        try:
            with open(self.ht_sysfs, 'r') as ht_sys:
                for line in ht_sys:
                    self.cpu_ht_enabled = int(line.strip('\n'))
        except IOError:
            # if HT status not available, assume HT enabled if coretemps are
            # less than CPU count
            self.cpu_ht_enabled = psutil.cpu_count() > len(psutil.sensors_temperatures()['coretemp']) - 1

        # get sibling per CPU core information
        num_cpu = int(self.cpu_num / 2) if self.cpu_ht_enabled else self.cpu_num
        for i in range(self.cpu_num):
            self.cpu_sysfs_siblings.append(
                f"/sys/devices/system/cpu/cpu{i}/topology/thread_siblings_list")
        try:
            sysfs_files = []
            for cpu in self.cpu_sysfs_siblings:
                cpu_sysfs = Path(cpu).resolve()
                if cpu_sysfs.is_file():
                    with open(cpu_sysfs, 'r') as sysfs:
                        sysfs_files.append(sysfs)
                        for line in sysfs:
                            pair = line.strip('\n').split(',')
                            if len(self.cpu_siblings) < num_cpu:
                                self.cpu_siblings[int(pair[0])] = int(pair[1])
                            else:
                                self.cpu_siblings[int(pair[1])] = int(pair[0])
            # create CPU temp sensort list
            j = 0
            once = True
            for c in self.cpu_siblings:
                if j > 5 and once:
                    j = 0
                    once = False
                self.cpu_temp_sensors.append(j)
                j += 1
        except IOError as e:
            print(f"Error sysfs CPU siblings {e}")

    def sanitise_thermal_modes(self, modes):
        """sanitise_thermal_modes.

        :param modes:
        """
        if "Current Thermal Modes: " in modes:
            modes.remove("Current Thermal Modes: ")
        if "Current Thermal Modes:" in modes:
            modes.remove("Current Thermal Modes:")
        if "Supported Thermal Modes: " in modes:
            modes.remove("Supported Thermal Modes: ")
        if "Supported Thermal Modes:" in modes:
            modes.remove("Supported Thermal Modes:")
        if "" in modes:
            modes.remove("")
        modes = [i.strip() for i in modes]
        # modes = [*set(modes)]
        s_modes = []
        [s_modes.append(x) for x in modes if x not in s_modes]
        return s_modes

    def load_settings(self):
        """load_settings."""
        # load continuous data collection setting
        always_on = str(self.settings.value('always_on'))
        if always_on and always_on.lower() == 'false':
            self.always_on = False
            self.always_on_checkbox.setCheckState(Qt.Unchecked)
        else:
            self.always_on = True
            self.always_on_checkbox.setCheckState(Qt.Checked)

        # load monitoring interval setting
        self.monitor_interval = int(str(self.settings.value('interval', 1000)))

        # load average CPU freq. setting
        use_cpu_ave_freq = str(self.settings.value('use_cpu_ave_freq'))
        if use_cpu_ave_freq and use_cpu_ave_freq.lower() == 'true':
            self.use_cpu_ave_freq = True
            self.cpu_ave_freq_checkbox.setCheckState(Qt.Checked)
        else:
            self.use_cpu_ave_freq = False
            self.cpu_ave_freq_checkbox.setCheckState(Qt.Unchecked)

        # load smbios information from config
        info = list(self.settings.value('smbios', []))
        if info:
            # reconstruct list back into dict preserving order
            self.smbios_info = {
                info[i][0]: info[i][1]
                for i in range(0, len(info))
            }
            self.smbios_button.setDisabled(True)

        # load bios thermal mode setting
        bios_thermal_control_on = str(self.settings.value(
            'bios_thermal_control_on'))

        # load current mode
        self.current_thermal_mode = self.settings.value('current_thermal_mode')

        # load supported thermal modes setting
        supported_thermal_modes = self.settings.value(
            'supported_thermal_modes')

        # setup bios thermal mode setting
        if bios_thermal_control_on is None:
            self.bios_thermal_control_on = False
        elif bios_thermal_control_on.lower() == 'true':
            self.bios_thermal_control_on = True
        elif bios_thermal_control_on.lower() == 'false':
            self.bios_thermal_control_on = False
        if supported_thermal_modes is None:
            self.supported_thermal_modes = []
        else:
            self.supported_thermal_modes = list(supported_thermal_modes)

        for mode in self.supported_thermal_modes:
            self.thermal_modes[mode] = mode.lower().replace(" ", "-")

        # check current status of i8kmon services.
        i8k_is_active = self.check_thermal_control()

        # set system to last known settings or default
        if not self.bios_thermal_control_on and not i8k_is_active:
            self.thermal_error_dialog(cmd='disable')
        elif self.bios_thermal_control_on and i8k_is_active:
            self.thermal_error_dialog(cmd='enable')
        if self.bios_thermal_control_on:
            self.thermal_checkbox.setChecked(True)
        else:
            self.thermal_checkbox.setChecked(False)

    def save_settings(self):
        """save_settings."""
        self.settings.setValue('current_thermal_mode',
                               self.current_thermal_mode)
        self.settings.setValue('supported_thermal_modes',
                               self.supported_thermal_modes)
        self.settings.setValue('bios_thermal_control_on',
                               self.bios_thermal_control_on)
        self.settings.setValue('always_on', self.always_on)
        self.settings.setValue('use_cpu_ave_freq', self.use_cpu_ave_freq)
        self.settings.setValue('interval', self.monitor_interval)
        if self.smbios_info:
            # preserve ordering by storing a list
            self.settings.setValue('smbios', list(self.smbios_info.items()))

    def enable_thermal_control(self, checked):
        """enable_thermal_control.

        :param checked:
        """
        if checked == Qt.Checked:
            self.bios_thermal_control(op='enable')
        else:
            self.bios_thermal_control(op='disable')

    def always_collect(self, checked):
        """always_collect.

        :param checked:
        """
        if checked == Qt.Checked:
            self.monitor_interval = int(self.interval_input.text())
            self.monitorTimer.setInterval(self.monitor_interval)
            self.always_on = True
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()
            self.monitorTimer.start()
        else:
            self.always_on = False
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()

    def enable_ave_cpu_freq(self, checked):
        """enable_ave_cpu_freq.

        :param checked:
        """
        self.use_cpu_ave_freq = checked == Qt.Checked

    def save_dialog_settings(self):
        """save_dialog_settings."""
        if self.monitor_interval != int(self.interval_input.text()):
            self.monitor_interval = int(self.interval_input.text())
            self.monitorTimer.setInterval(self.monitor_interval)
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()
                self.monitorTimer.start()
        self.save_settings()
        self.settings_dialog.close()

    def close_info_dialog(self):
        """close_info_dialog."""
        self.save_settings()
        self.info_dialog.close()

    def smbios_message(self, msg):
        """smbios_message.

        :param msg:
        """
        split_msg = msg.split(': ')
        for item in split_msg:
            split_item = item.split('\n')
            for part_item in split_item:
                self.smbios_data.append(part_item.strip())

    def check_thermal_control(self):
        """check_thermal_control."""
        if self.p is not None:
            return

        active_services = []
        # check service files are available
        dell_service_file = Path(
            '/etc/systemd/system/dell-bios-fan-control.service')
        if not dell_service_file.is_file():
            print(
                "Error systemctl dell-bios-fan-control.service not found")
            return False

        i8k_service_file = Path('/lib/systemd/system/i8kmon.service')
        if not i8k_service_file.is_file():
            print("Error systemctl i8kmon.service not found")
            return False

        # check which system services are active.
        # keep a reference to the QProcess (e.g. on self)
        # while it's running.
        self.p = QProcess()
        self.p.start("systemctl", ['is-active', 'i8kmon.service'])
        self.p.waitForFinished()
        result = self.p.readLine()
        output = bytes(result).decode("utf8")
        is_active = output.strip('\n')
        if is_active == "active":
            active_services.append(True)
        self.p.close()
        self.p = None

        # keep a reference to the QProcess (e.g. on self)
        # while it's running.
        self.p = QProcess()
        self.p.start("systemctl",
                     ['is-active', 'dell-bios-fan-control.service'])
        self.p.waitForFinished()
        result = self.p.readLine()
        output = bytes(result).decode("utf8")
        is_active = output.strip('\n')
        self.p.close()
        self.p = None
        if is_active == "active":
            active_services.append(True)
        # i8kmon requires 2 services active, or
        # no services active (BIOS mode). Any other
        # combination is a fail.
        return len(active_services) == 2

    def check_prerequisites(self):
        """check_thermal_prerequisites. Check for i8k and SMBIOS."""
        # check sysfs
        self.power_sysfs = "/sys/class/power_supply/AC/online"
        self.scaling_sysfs = "/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"
        self.tdp = "/sys/devices/virtual/powercap/intel-rapl/intel-rapl:0/constraint_0_max_power_uw"
        self.ht_sysfs = "/sys/devices/system/cpu/smt/active"
        cpu_siblings_sysfs = "/sys/devices/system/cpu/cpu0/topology/thread_siblings_list"
        sysfs_passed = bool(
            (
                Path(self.power_sysfs).is_file()
                and Path(self.scaling_sysfs).is_file()
                and Path(self.tdp).is_file()
                and Path(self.ht_sysfs).is_file()
                and Path(cpu_siblings_sysfs).is_file()
            )
        )
        # check cpu coretemp sysfs interface
        try:
            for cpu in range(self.num_phy_cores):
                self.coretemps_sysfs.append(
                    glob.glob(f"/sys/devices/platform/coretemp.0/hwmon/*/temp{cpu + 1}_input")[0]
                )
            for t in self.coretemps_sysfs:
                temp = Path(t).resolve()
                if not temp.is_file():
                    print(f"error file {t} is not available")
        except IOError:
            return False
        # check for i8k
        self.i8kmon_ctl = shutil.which("i8kctl")
        self.i8kmon_fan1 = glob.glob(
            "/sys/module/dell_smm_hwmon/drivers/platform:dell_smm_hwmon/dell_smm_hwmon/hwmon/*/fan1_input"
        )[0]
        self.i8kmon_fan2 = glob.glob(
            "/sys/module/dell_smm_hwmon/drivers/platform:dell_smm_hwmon/dell_smm_hwmon/hwmon/*/fan2_input"
        )[0]
        self.i8kmon_fan1_target = glob.glob(
            "/sys/module/dell_smm_hwmon/drivers/platform:dell_smm_hwmon/dell_smm_hwmon/hwmon/*/fan1_target"
        )[0]
        self.i8kmon_fan2_target = glob.glob(
            "/sys/module/dell_smm_hwmon/drivers/platform:dell_smm_hwmon/dell_smm_hwmon/hwmon/*/fan2_target"
        )[0]
        self.i8kmon_temp = glob.glob(
            "/sys/module/dell_smm_hwmon/drivers/platform:dell_smm_hwmon/dell_smm_hwmon/hwmon/*/temp1_input"
        )[0]
        i8kmon_passed = bool(
            (
                Path(self.i8kmon_fan1).is_file()
                and Path(self.i8kmon_fan2).is_file()
                and Path(self.i8kmon_fan1_target).is_file()
                and Path(self.i8kmon_fan2_target).is_file()
                and Path(self.i8kmon_temp).is_file()
            )
        )
        self.i8kmon_conf = Path("/etc/i8kmon.conf").resolve()
        # check for smbios-thermal-ctl
        self.smbois_ctl = Path(str(shutil.which("smbios-thermal-ctl"))).resolve()
        # if i8k is not available to gather fan rpms then information can be
        # taken from the dell_smm_hwmon kernel module
        if sysfs_passed and i8kmon_passed and Path(str(
                self.i8kmon_ctl)).is_file() and Path(
                    self.smbois_ctl).is_file():
            self.get_i8k_information()
            return True
        # else disable menu and return False
        self.thermal_control_menu.setTitle("Thermal Control N/A")
        self.thermal_menu_group.setDisabled(True)
        self.alternative_cpu_temp = True
        return False

    def bios_thermal_control(self, op=None):
        """bios_thermal_control.

        :param op:
        """
        # enable or disable BIOS thermal control
        if self.p is not None:
            return False

        # find smbios script
        thermal_file = Path(str(shutil.which("i8kgui_thermal_control")))
        if not thermal_file.is_file():
            thermal_file = Path("i8kgui_thermal_control")
        # enable bios control and disable i8kmon
        if op == 'enable':
            self.p = QProcess()
            self.p.readyReadStandardOutput.connect(
                self.handle_thermal_stdout)
            self.p.readyReadStandardError.connect(
                self.handle_thermal_stderr)
            self.p.stateChanged.connect(self.handle_process_state)
            # clean up once complete
            self.p.finished.connect(self.thermal_process_finished)
            self.p.start("pkexec",
                         [str(thermal_file.resolve()), '--enable'])
        # disable bios control and enable i8kmon
        elif op == 'disable':
            self.p = QProcess()
            self.p.readyReadStandardOutput.connect(
                self.handle_thermal_stdout)
            self.p.readyReadStandardError.connect(
                self.handle_thermal_stderr)
            self.p.stateChanged.connect(self.handle_process_state)
            # clean up once complete
            self.p.finished.connect(self.thermal_process_disable_finished)
            self.p.start("pkexec",
                         [str(thermal_file.resolve()), '--disable'])
        # get BIOS controlled thermal mode
        elif op == 'status':
            self.p = QProcess()
            self.p.readyReadStandardOutput.connect(
                self.handle_thermal_stdout)
            self.p.readyReadStandardError.connect(
                self.handle_thermal_stderr)
            self.p.stateChanged.connect(self.handle_process_state)
            # clean up once complete
            self.p.finished.connect(self.thermal_process_finished)
            self.p.start("pkexec",
                         [str(thermal_file.resolve()), '--status'])

    def handle_thermal_stderr(self):
        """handle_thermal_stderr."""
        if self.p:
            data = self.p.readAllStandardError()
            stderr = bytes(data).decode("utf8")
            # check if pkexec passwd input cancelled
            if 'Request dismissed' in stderr:
                self.p.finished.emit(1, QProcess.CrashExit)
            else:
                print(f"Error: handle_thermal_stderr {stderr}")

    def handle_thermal_stdout(self):
        """handle_thermal_stdout."""
        if not self.p:
            return

        data = self.p.readAllStandardOutput()
        stdout = bytes(data).decode("utf8")

        # get supported BIOS thermal modes
        if stdout.startswith('Supported Thermal Modes'):
            split_stdout = stdout.split('\n')
            split_stdout = self.sanitise_thermal_modes(split_stdout)
            for item in split_stdout:
                self.supported_thermal_modes_data.append(item)
        # get current thermal mode
        elif stdout.startswith('Current Thermal Modes'):
            split_stdout = stdout.split('\n')
            split_stdout = self.sanitise_thermal_modes(split_stdout)
            for item in split_stdout:
                self.current_thermal_mode_data.append(item)
        # get return from successful change of mode
        elif stdout.startswith('Helper function to Set Thermal Mode'):
            split_stdout = stdout.split(': ')
            self.current_thermal_mode = split_stdout[1].strip().title(
            ).replace("-", " ")
        elif stdout.startswith('Status Current Thermal Modes'):
            print(f"stdout {stdout}")
            split_stdout = stdout.split('\n')
            split_stdout = self.sanitise_thermal_modes(split_stdout)
            for item in split_stdout:
                self.current_thermal_mode_data.append(item)

    def close_process(self):
        """close_process."""
        if self.p and self.p.state() != 0:
            self.p.close()
        self.p = None

    def kill_process(self):
        """kill_process."""
        try:
            if self.p:
                self.p.terminate()
                self.p.waitForFinished(1000)
                self.p.kill()
        except Exception:
            pass
        self.p = None

    def thermal_selection_finished(self):
        """thermal_selection_finished."""
        # bios mode change
        if self.p and self.p.exitCode() != 0:
            self.kill_process()
            return
        else:
            self.close_process()
            self.update_thermal_modes()

    def thermal_process_finished(self):
        """thermal_process_finished."""
        # switch between i8k and bios modes
        if self.p and self.p.exitCode() != 0:
            self.kill_process()
            self.thermal_checkbox.setChecked(False)
            self.bios_thermal_control_on = False
            self.supported_thermal_modes_data = []
            self.current_thermal_mode_data = []
            return
        else:
            self.close_process()
            self.update_thermal_modes()

    def thermal_process_disable_finished(self):
        """thermal_process_disable_finished."""
        if self.p and self.p.exitCode() != 0:
            self.kill_process()
            self.thermal_checkbox.setChecked(True)
            self.bios_thermal_control_on = True
            self.supported_thermal_modes_data = []
            self.current_thermal_mode_data = []
            return
        else:
            self.close_process()
            self.update_thermal_modes()

    def update_thermal_modes(self):
        """update_thermal_modes."""
        if self.supported_thermal_modes_data:
            self.supported_thermal_modes = self.sanitise_thermal_modes(
                self.supported_thermal_modes_data)
            # make dict with display and machine name variantions
            for mode in self.supported_thermal_modes:
                self.thermal_modes[mode] = mode.lower().replace(" ", "-")
            self.supported_thermal_modes_data = []

        if self.current_thermal_mode_data:
            self.current_thermal_mode_data = self.sanitise_thermal_modes(
                self.current_thermal_mode_data)
            self.current_thermal_mode = self.current_thermal_mode_data[
                0].title().replace("-", " ")
            self.current_thermal_mode_data = []
        # debug
        # print(f"disable supported modes: {self.supported_thermal_modes}")
        # print(f"disable current mode {self.current_thermal_mode}")
        self.bios_thermal_control_on = bool(self.thermal_checkbox.isChecked(
        ) and self.current_thermal_mode is not None)
        self.switch_thermal_menu()

    def switch_thermal_menu(self):
        """switch_thermal_menu."""
        # remove and re-build thermal menu
        self.remove_thermal_menu()
        self.build_thermal_menu()

    def remove_thermal_menu(self):
        """remove_thermal_menu."""
        actions = self.thermal_menu_group.actions()
        for action in actions:
            self.thermal_control_menu.removeAction(action)
            self.thermal_menu_group.removeAction(action)
        self.thermal_menu_group.setEnabled(False)

    def build_thermal_menu(self):
        """build_thermal_menu."""
        if self.thermal_menu_group.actions():
            return

        if self.bios_thermal_control_on:
            if self.thermal_modes:
                for _name, _mach_name in self.thermal_modes.items():
                    thermal_menu_item = QAction(_name)
                    thermal_menu_item.setObjectName(_mach_name)
                    thermal_menu_item.setCheckable(True)
                    self.thermal_control_menu.addAction(thermal_menu_item)
                    self.thermal_menu_group.addAction(thermal_menu_item)
                self.thermal_menu_group.setEnabled(True)
                self.thermal_control_menu.setTitle("BIOS Thermal Management")
                actions = self.thermal_menu_group.actions()
                for action in actions:
                    if action.text() == self.current_thermal_mode:
                        action.setChecked(True)
        else:
            self.i8k_info = self.get_i8k_information()
            if self.i8k_info:
                for key, value in self.i8k_info.items():
                    if key.startswith('Fan Mode'):
                        mode = key.split('Fan Mode ')
                        if int(mode[1]) == self.left_fan_mode:
                            if self.ac_power_supply_on:
                                title = (
                                    f"{key}: Low: {value[0]}{self.degree_sign}C  "
                                    f"High: {value[1]}{self.degree_sign}C")
                            else:
                                title = (
                                    f"{key}: Low: {value[2]}{self.degree_sign}C  "
                                    f"High: {value[3]}{self.degree_sign}C")
                            self.fan_mode_menu_item.setText(title)
                            self.thermal_control_menu.addAction(
                                self.fan_mode_menu_item)
                            self.thermal_menu_group.addAction(
                                self.fan_mode_menu_item)
                    elif key.startswith('Left Speed'):
                        title = f"Max {key}: {value[self.left_fan_mode]}"
                        self.left_fan_thermal_menu_item.setText(title)
                        self.thermal_control_menu.addAction(
                            self.left_fan_thermal_menu_item)
                        self.thermal_menu_group.addAction(
                            self.left_fan_thermal_menu_item)
                    elif key.startswith('Right Speed'):
                        title = f"Max {key}: {value[self.right_fan_mode]}"
                        self.right_fan_thermal_menu_item.setText(title)
                        self.thermal_control_menu.addAction(
                            self.right_fan_thermal_menu_item)
                        self.thermal_menu_group.addAction(
                            self.right_fan_thermal_menu_item)
                    else:
                        title = f"{key}: {value}{self.degree_sign}C"
                        thermal_menu_item = QAction(title)
                        thermal_menu_item.setCheckable(False)
                        self.thermal_control_menu.addAction(thermal_menu_item)
                        self.thermal_menu_group.addAction(thermal_menu_item)
            self.thermal_menu_group.setEnabled(True)
            self.thermal_control_menu.setTitle(
                "I8K Thermal Management")

    def build_cpu_menu(self):
        """build_cpu_menu."""
        # build menu for per CPU core information
        for i in range(self.cpu_num):
            self.cpu_curr_freqs.append(
                f"/sys/devices/system/cpu/cpu{i}/cpufreq/scaling_cur_freq")
            c_action = QAction(f"CPU {i}")
            c_action.setCheckable(False)
            self.cpu_details.addAction(c_action)
            self.cpu_freq_list.append(c_action)

    def get_cpu_tdp(self):
        """get_cpu_tdp."""
        with open(self.tdp, 'r') as f:
            self.cpu_tdp.setText(f"{int(f.read().strip()) // 1000000} W")
        return self.cpu_tdp

    def get_i8k_information(self):
        """get_i8k_information."""
        if self.critical_error:
            return

        info = {}
        i8k_config = None
        try:
            i8k_config = open(self.i8kmon_conf, 'r')
        except IOError as e:
            self.critical_error = True
            if self.tray:
                self.tray.showMessage("i8kgui",
                                      f"Error cannot find /etc/i8kmon.conf. "
                                      f"Please check your config file \n\n{e}",
                                      icon=QSystemTrayIcon.Critical,
                                      msecs=10000)
        else:
            if i8k_config:
                for line in i8k_config:
                    if line.startswith('set config(t_high)'):
                        conf = line.split('set config(t_high)')[1].strip()
                        info['High CPU Temp'] = conf
                    if line.startswith('set config(0)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 0'] = list(conf[1].split())
                    if line.startswith('set config(1)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 1'] = list(conf[1].split())
                    if line.startswith('set config(2)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 2'] = list(conf[1].split())
                    if line.startswith('set config(3)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 3'] = list(conf[1].split())
                    if line.startswith('set status(leftspeed)'):
                        conf = line.split(
                            "set status(leftspeed)")[1].strip().strip('"')
                        info['Left Speed'] = list(conf.split())
                    if line.startswith('set status(rightspeed)'):
                        conf = line.split(
                            "set status(rightspeed)")[1].strip().strip('"')
                        info['Right Speed'] = list(conf.split())
                i8k_config.close()
        return info

    def get_smbios_information(self):
        """get_smbios_information."""
        if self.p is not None:
            return

        # find smbios script
        smbios_file = Path(str(shutil.which("smbios-sys-info")))
        if not smbios_file.is_file():
            if self.tray:
                self.tray.showMessage(
                    "i8kgui",
                    "Error please install python3-libsmbios, "
                    "smbios-sys-info not found",
                    icon=QSystemTrayIcon.Critical,
                    msecs=10000)
            return
        # self.smbios_message("Executing process")
        # Keep a reference to the QProcess (e.g. on self)
        # while it's running.
        self.p = QProcess()
        self.p.readyReadStandardOutput.connect(self.handle_smbios_stdout)
        self.p.readyReadStandardError.connect(self.handle_smbios_stderr)
        self.p.stateChanged.connect(self.handle_process_state)
        # Clean up once complete.
        self.p.finished.connect(self.smbios_process_finished)
        self.p.start("pkexec", [str(smbios_file.resolve())])

    def handle_smbios_stderr(self):
        """handle_smbios_stderr."""
        if self.p:
            data = self.p.readAllStandardError()
            stderr = bytes(data).decode("utf8")
            if 'Request dismissed' in stderr:
                self.p.finished.emit(1, QProcess.CrashExit)
            else:
                print(f"Error: handle_smbios_stderr {stderr}")

    def handle_smbios_stdout(self):
        """handle_smbios_stdout."""
        if self.p:
            data = self.p.readAllStandardOutput()
            stdout = bytes(data).decode("utf8")
            self.smbios_message(stdout)

    def handle_process_state(self, state):
        """handle_process_state.

        :param state:
        """
        states = {
            QProcess.NotRunning: 'NotRunning',
            QProcess.Starting: 'Starting',
            QProcess.Running: 'Running',
        }
        self.p_state = states[state]

    def smbios_process_finished(self):
        """smbios_process_finished."""
        if self.p and self.p.exitCode() != 0:
            self.kill_process()
        else:
            self.close_process()
            self.process_smbios_data()

    def process_smbios_data(self):
        """process_smbios_data."""
        if self.smbios_data:
            self.smbios_data.pop()  # remove white space
            self.smbios_info = {
                self.smbios_data[i]: self.smbios_data[i + 1]
                for i in range(0, len(self.smbios_data), 2)
            }  # convert data to dict
            self.smbios_data = []  # empty data container
            f_layout = self.info_dialog.layout()
            for key, value in self.smbios_info.items():
                f_layout.insertRow(f_layout.rowCount() - 2, str(key),
                                   QLabel(str(value)))
            self.smbios_button.setDisabled(True)

    def create_info_dialog(self):
        """create_info_dialog."""
        close_button = QPushButton("close", self.info_dialog)
        close_button.setMaximumWidth(100)
        close_button.clicked.connect(self.close_info_dialog)

        self.smbios_button.setMaximumWidth(250)
        self.smbios_button.clicked.connect(self.get_smbios_information)

        f_layout = QFormLayout()
        f_layout.addRow("CPU Model", self.cpu_model)
        f_layout.addRow("CPU TDP", self.get_cpu_tdp())
        f_layout.addRow("i8k Format Version", self.i8k_format_version)
        f_layout.addRow("BIOS Version", self.bios_version)
        f_layout.addRow("Service Tag", self.service_tag)
        f_layout.addRow("A/C Power Supply", self.power_status)
        f_layout.addRow("Button Status", self.button_status)
        f_layout.addRow(" ", None)
        f_layout.addRow("(requires password)", self.smbios_button)
        f_layout.addRow(" ", None)
        f_layout.addRow(" ", None)
        f_layout.addWidget(close_button)
        if self.smbios_info:
            for key, value in self.smbios_info.items():
                f_layout.insertRow(f_layout.rowCount() - 2, str(key),
                                   QLabel(str(value)))
        self.info_dialog.setLayout(f_layout)
        # set dialog geometry
        self.info_dialog.setWindowTitle("Information")
        self.info_dialog.setWindowModality(QtCore.Qt.ApplicationModal)
        self.info_dialog.setMinimumWidth(450)
        self.info_dialog.setMaximumWidth(600)
        self.info_dialog.setMaximumHeight(600)
        center_point = QScreen.availableGeometry(
            QApplication.primaryScreen()).center()
        fg = self.info_dialog.frameGeometry()
        fg.moveCenter(center_point)
        self.info_dialog.move(fg.topLeft())

    def create_settings_dialog(self):
        """create_settings_dialog."""
        self.save_button.setMaximumWidth(100)

        self.always_on_checkbox.setText("Collect statistics continuously")
        self.always_on_checkbox.stateChanged.connect(self.always_collect)

        self.thermal_checkbox.setText("Enable BIOS thermal management")
        self.thermal_checkbox.stateChanged.connect(self.enable_thermal_control)

        self.cpu_ave_freq_checkbox.setText("Display average CPU freq.")
        self.cpu_ave_freq_checkbox.stateChanged.connect(
            self.enable_ave_cpu_freq)

        self.interval_input.setValidator(QIntValidator())
        self.interval_input.setMaxLength(6)
        self.interval_input.setText(str(self.monitor_interval))

        self.save_button.clicked.connect(self.save_dialog_settings)
        f_layout = QFormLayout()
        f_layout.addRow("(requires password)", self.thermal_checkbox)
        f_layout.addRow(" ", self.always_on_checkbox)
        f_layout.addRow(" ", self.cpu_ave_freq_checkbox)
        f_layout.addRow(" ", None)
        f_layout.addRow("Monitoring Interval (milliseconds):",
                        self.interval_input)
        f_layout.addRow(" ", None)
        f_layout.addRow(self.save_button)
        self.settings_dialog.setLayout(f_layout)
        # set dialog geometry
        self.settings_dialog.setWindowTitle("Settings")
        self.settings_dialog.setWindowModality(QtCore.Qt.ApplicationModal)
        self.settings_dialog.setMaximumWidth(400)
        self.settings_dialog.setMaximumHeight(400)
        center_point = QScreen.availableGeometry(
            QApplication.primaryScreen()).center()
        fg = self.settings_dialog.frameGeometry()
        fg.moveCenter(center_point)
        self.settings_dialog.move(fg.topLeft())

    def load_sys_tray(self):
        """load_sys_tray."""
        # build desktop system tray
        self.tray = QSystemTrayIcon(self)
        if self.tray.isSystemTrayAvailable():
            # check system then user icon locations
            icon_file = Path("/usr/share/icons/i8kgui_icon.png").resolve()
            if not icon_file.is_file():
                icon_file = Path(f'{str(Path.home())}/.local/share/icons/i8kgui_icon.png').resolve()
                if not icon_file.is_file():
                    pass
            icon = QIcon(str(icon_file))
            if icon.pixmap(QSize(64, 64)).isNull():
                icon = QIcon('icons/i8kgui_icon.png')
            self.tray.setIcon(icon)
            self.tray.activated.connect(self.status)
            self.tray.messageClicked.connect(self.message_clicked)
            # workaround because tray activated only works with double click
            self.tray_menu.aboutToShow.connect(self.monitor)
            self.tray_menu.aboutToHide.connect(self.stop_monitor)
            # setup display
            self.tray_menu.addAction(self.cpu_usage)
            self.tray_menu.addAction(self.cpu_mhz)
            self.tray_menu.addAction(self.cpu_governor)
            self.connect_cpupower()
            self.tray_menu.addAction(self.cpu_temp)
            self.tray_menu.addMenu(self.cpu_details)
            self.tray_menu.addAction(self.left_fan_rpm)
            self.tray_menu.addAction(self.right_fan_rpm)
            self.tray_menu.addAction(self.left_fan_status)
            self.tray_menu.addAction(self.right_fan_status)
            self.tray_menu.addSeparator()
            # setup thermal control management menu
            self.tray_menu.addMenu(self.thermal_control_menu)
            self.thermal_menu_group.setExclusive(True)
            self.thermal_menu_group.triggered.connect(
                self.thermal_mode_selection)
            self.build_thermal_menu()  # menu created based on settings
            self.tray_menu.addSeparator()
            # add info, settings and quit menu items
            action_info = self.tray_menu.addAction("Information")
            action_info.triggered.connect(self.show_info)
            action_settings = self.tray_menu.addAction("Settings")
            action_settings.triggered.connect(self.show_settings)
            action_quit = self.tray_menu.addAction("Quit")
            action_quit.triggered.connect(self.close_app)

            self.tray.setContextMenu(self.tray_menu)
            self.tray.setToolTip("i8kgui")
            self.tray.setVisible(True)
        else:
            QMessageBox.critical(
                None, "i8kgui", "Unable to locate system tray on this system.")
            self.close_app()

    def connect_cpupower(self):
        """connect_cpupower."""
        # connect to cpupower-gui if found
        cpupower_file = Path(str(shutil.which("cpupower-gui")))
        if cpupower_file.is_file():
            self.cpu_governor.triggered.connect(self.show_cpupower)
        # TODO - if not found show message to user to install

    def show_cpupower(self):
        """show_cpupower."""
        self.cpupower = QProcess()
        self.cpupower.start("cpupower-gui")
        self.cpupower.waitForFinished()
        result = self.cpupower.readLine()
        output = bytes(result).decode("utf8")
        if error := output.strip('\n'):
            print(f"Error: failed to load cpupower-gui {error}")
        self.cpupower.close()
        self.cpupower = None

    def thermal_mode_selection(self, checked):
        """thermal_mode_selection.

        :param checked:
        """
        if self.bios_thermal_control_on:
            if self.p is None:
                # find libsmbios script
                thermal_file = Path(str(shutil.which("smbios-thermal-ctl")))
                if not thermal_file.is_file():
                    if self.tray:
                        self.tray.showMessage(
                            "i8kgui",
                            "Error please install python3-libsmbios, "
                            "smbios-thermal-ctl not found.",
                            icon=QSystemTrayIcon.Critical,
                            msecs=10000)
                    return
                if self.current_thermal_mode != checked.text():
                    t_args = "--set-thermal-mode="
                    if checked.text() in self.thermal_modes:
                        t_args += self.thermal_modes[checked.text()]
                    else:
                        t_args += 'balanced'
                    # Keep a reference to the QProcess (e.g. on self)
                    # while it's running.
                    self.p = QProcess()
                    self.p.readyReadStandardOutput.connect(
                        self.handle_thermal_stdout)
                    self.p.readyReadStandardError.connect(
                        self.handle_thermal_stderr)
                    self.p.stateChanged.connect(self.handle_process_state)
                    # Clean up once complete.
                    self.p.finished.connect(self.thermal_selection_finished)
                    self.p.start("pkexec", [str(thermal_file.resolve()), t_args])
        else:
            print("Edit i8kmon config")  # TODO - add i8kmon config updating

    @Slot()
    def message_clicked(self):
        """message_clicked."""
        self.close_app()

    def read_i8kmon_info(self):
        """read_i8kmon_info."""
        with open(self.i8kmon_fan1) as fan1, \
                open(self.i8kmon_fan2) as fan2, \
                open(self.i8kmon_fan1_target) as fan1_target, \
                open(self.i8kmon_fan2_target) as fan2_target, \
                open(self.i8kmon_temp) as temp:
            # format inputs
            i8kmon_fan1 = fan1.readline().strip('\n')
            i8kmon_fan2 = fan2.readline().strip('\n')
            i8kmon_fan1_target = fan1_target.readline().strip('\n')
            i8kmon_fan2_target = fan2_target.readline().strip('\n')
            i8kmon_temp = temp.readline().strip('\n')
            # cpu temp
            c_temp = f"{float(i8kmon_temp.strip()) / 1000}{self.degree_sign}C".rjust(20)
            self.cpu_temp.setText(f"CPU Temp:\t{c_temp}")
            # left fan speed
            l_fan = f"{i8kmon_fan1.strip()}  RPM".rjust(22)
            self.left_fan_rpm.setText(f"Left Fan:\t{l_fan}")
            # right fan speed
            r_fan = f"{i8kmon_fan2.strip()}  RPM".rjust(22)
            self.right_fan_rpm.setText(f"Right Fan:\t{r_fan}")
            # left fan mode
            left_mode = f"{self.left_fan_mode_map[int(i8kmon_fan1_target.strip())]}".rjust(
                15)
            self.left_fan_status.setText(f"Left Fan Mode:{left_mode}")
            # right fan mode
            right_mode = f"{self.right_fan_mode_map[int(i8kmon_fan2_target.strip())]}".rjust(
                13)
            self.right_fan_status.setText(f"Right Fan Mode:{right_mode}")
            # update fan modes
            if self.left_fan_mode != int(
                    i8kmon_fan1_target.strip()) or self.right_fan_mode != int(
                        i8kmon_fan2_target.strip()):
                self.left_fan_mode = int(i8kmon_fan1_target.strip())
                self.right_fan_mode = int(i8kmon_fan2_target.strip())
                self.update_i8k_thermal()
            # update power status
            self.update_i8k_ac_power()
            self.power_status.setText(str(self.ac_power_supply_on))

    def read_cpu_info(self):
        """read_cpu_info."""
        # gather current CPU MHz.
        try:
            cpu_procs = []
            all_mhz = []
            for cpu in self.cpu_curr_freqs:
                with open(cpu, 'r') as proc:
                    cpu_procs.append(proc)
                    for temp in proc:
                        mhz = int(temp.strip('\n')) // 1000
                        all_mhz.append(mhz)
            coretemps = []
            for coretemp in self.coretemps_sysfs:
                with open(coretemp, 'r') as cpu_temps:
                    coretemps.extend(float(temp.strip('\n')) / 1000 for temp in cpu_temps)
        except IOError as e:
            self.critical_error = True
            if self.tray:
                self.tray.showMessage(
                    "i8kgui",
                    f"Error cannot find /proc/cpuinfo.\n\n{e}",
                    icon=QSystemTrayIcon.Critical,
                    msecs=10000,
                )
        else:
            usage = psutil.cpu_percent(interval=0.0, percpu=False)
            usage_per = psutil.cpu_percent(interval=0.0, percpu=True)
            c_use = f"{usage} %".rjust(20)
            self.cpu_usage.setText(f"CPU Usage:\t{c_use}")
            if self.use_cpu_ave_freq:
                total_mhz = sum(all_mhz)
                mhz = total_mhz // len(all_mhz)
            else:
                all_mhz.sort()
                mhz = all_mhz[-1]
            c_mhz = f"{mhz} MHz".rjust(20)
            self.cpu_mhz.setText(
                f"CPU Freq:\t{c_mhz}")
            for i, c in enumerate(self.cpu_freq_list):
                j = self.cpu_temp_sensors[i]
                # CPU number - 7 chars "CPU 01:"
                _num = str("{:02d}".format(i))
                cpu_text = f"CPU {_num}:"
                # CPU usage - 7 chars "100.0 %"
                usage = str(usage_per[i]).center(5)
                usage_text = f"{usage} %"
                # CPU MHz - 8 chars "4000 MHz"
                mhz_text = f"{all_mhz[i]:04d} MHz"
                # CPU core Temp - 7 chars "100 C"
                temp = str("{:2.0f}".format(coretemps[j])).rjust(4)
                temp_text = f"{temp}{self.degree_sign}C"
                # Output "CPU 01: 100.0 % 4000 MHz 80 C" - total 29 chars
                per_cpu_text = cpu_text.rjust(7)+usage_text.center(10)+mhz_text.center(9)+temp_text.ljust(7)
                c.setText(f"{per_cpu_text}".center(36))

    def read_cpu_gov_info(self):
        """read_cpu_gov_info."""
        # gather current CPU governor
        gov_sys = None
        try:
            with open(self.scaling_sysfs, 'r') as gov_sys:
                gov = gov_sys.readline().strip()
                gov_sys.close()
                self.cpu_governor.setText(
                    f"CPU Governor:       {gov.capitalize()}")
        except IOError as e:
            self.critical_error = True
            if self.tray:
                self.tray.showMessage(
                    "i8kgui",
                    f"Error cannot find "
                    f"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor."
                    f"\n\n{e}",
                    icon=QSystemTrayIcon.Critical,
                    msecs=10000)

    def read_power_supply_status(self):
        """read_power_supply_status."""
        # gather power supply status
        with open(self.power_sysfs, 'r') as pwr_sys:
            pwr_ac = pwr_sys.readline().strip()
            self.ac_power_supply_on = int(pwr_ac) == 1

    def read_proc(self):
        """read_proc."""
        # read i8k, CPU and power values then update the system tray
        # and send a fake click to initiate live updating while
        # the system tray is in active use.
        if self.critical_error:
            return
        self.read_power_supply_status()
        self.read_i8kmon_info()
        self.read_cpu_info()
        self.read_cpu_gov_info()
        # send fake single-click event as workaround
        if self.tray:
            self.tray.activated.emit(QSystemTrayIcon.Trigger)

    def update_i8k_ac_power(self):
        """update_i8k_ac_power."""
        # update i8k thermal menu fan mode based on A/C power supply status
        if not self.i8k_info:
            return

        for key, value in self.i8k_info.items():
            if key.startswith('Fan Mode'):
                mode = key.split('Fan Mode ')
                if int(mode[1]) == self.left_fan_mode:
                    if self.ac_power_supply_on:
                        title = (f"{key}: Low: "
                                 f"{value[0]}{self.degree_sign}C  "
                                 f"High: {value[1]}{self.degree_sign}C")
                    else:
                        title = (f"{key}: Low: "
                                 f"{value[2]}{self.degree_sign}C  "
                                 f"High: {value[3]}{self.degree_sign}C")
                    self.fan_mode_menu_item.setText(title)
                    break

    def update_i8k_thermal(self):
        """update_i8k_thermal."""
        # update i8k thermal menu. Activated when i8k changes fan mode.
        if not self.i8k_info:
            self.i8k_info = self.get_i8k_information()
        if self.i8k_info:
            for key, value in self.i8k_info.items():
                if key.startswith('Fan Mode'):
                    mode = key.split('Fan Mode ')
                    if int(mode[1]) == self.left_fan_mode:
                        if self.ac_power_supply_on:
                            title = (f"{key}: Low: "
                                     f"{value[0]}{self.degree_sign}C  "
                                     f"High: {value[1]}{self.degree_sign}C")
                        else:
                            title = (f"{key}: Low: "
                                     f"{value[2]}{self.degree_sign}C  "
                                     f"High: {value[3]}{self.degree_sign}C")
                        self.fan_mode_menu_item.setText(title)
                elif key.startswith('Left Speed'):
                    title = f"Max {key}: {value[self.left_fan_mode]}"
                    self.left_fan_thermal_menu_item.setText(title)
                elif key.startswith('Right Speed'):
                    title = f"Max {key}: {value[self.right_fan_mode]}"
                    self.right_fan_thermal_menu_item.setText(title)

    def status(self, reason):
        """status.

        :param reason:
        """
        # start live updating of values if system tray is in active use,
        # and employ workaround for timer being started upon load.
        if reason == QSystemTrayIcon.ActivationReason.Trigger:
            if not self.monitorTimer.isActive():
                if not self.first_load:
                    self.monitorTimer.start()
                else:
                    # workaround to not start QTimer
                    # when tray is loaded first time
                    self.first_load = False

    def monitor(self):
        """monitor."""
        self.read_proc()

    def refresh_monitor(self):
        """refresh_monitor."""
        self.read_proc()

    def stop_monitor(self):
        """stop_monitor."""
        if not self.always_on and self.monitorTimer.isActive():
            self.monitorTimer.stop()

    def show_settings(self):
        """show_settings."""
        if not self.settings_dialog.isVisible():
            self.settings_dialog.show()
        self.settings_dialog.raise_()
        self.settings_dialog.setFocus()

    def show_info(self):
        """show_info."""
        with os.popen(self.i8kmon_ctl) as ctl:
            line = ctl.readline().strip('\n').strip()
            split_line = line.split(" ")
            self.i8k_format_version.setText(split_line[0].strip())
            self.bios_version.setText(split_line[1].strip())
            self.service_tag.setText(split_line[2].strip())
            self.button_status.setText(split_line[9].strip())

        if not self.info_dialog.isVisible():
            self.info_dialog.show()
        self.info_dialog.raise_()
        self.info_dialog.setFocus()


if __name__ == '__main__':
    app = QApplication([])
    app.setOrganizationName("i8kgui")
    app.setApplicationName("i8kgui")
    app.setApplicationVersion("0.8.2")
    # setup Dark Mode QPalette - initial setup
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Light, QColor(68, 68, 68))
    palette.setColor(QPalette.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ToolTipBase, Qt.white)
    palette.setColor(QPalette.ToolTipText, Qt.black)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218, 192))
    palette.setColor(QPalette.HighlightedText, Qt.white)
    # setup Dark Mode disabled QPalette
    palette.setColor(QPalette.Disabled, QPalette.Window, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.WindowText,
                     QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.Base, QColor(68, 68, 68))
    palette.setColor(QPalette.Disabled, QPalette.Text,
                     QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.Button,
                     QColor(53, 53, 53, 128))
    palette.setColor(QPalette.Disabled, QPalette.ButtonText,
                     QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.BrightText, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.Link, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.Highlight, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.HighlightedText, Qt.black)
    # add Dark Mode to i8kgui
    app.setPalette(palette)

    app.setQuitOnLastWindowClosed(False)
    tray = I8kGui()

    app.exec()
