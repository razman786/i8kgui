#!/usr/bin/env python3
# Copyright (c) 2022, Dr Rahim Lakhoo, razman786@gmail.com.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.
#

from pathlib import Path
import shutil
import warnings

from PySide6 import QtCore
from PySide6.QtCore import QProcess, QSettings, QSize, Slot, QTimer
from PySide6.QtGui import (QAction, QActionGroup, QColor, QIcon, QIntValidator,
                           QPalette, QScreen, Qt)
from PySide6.QtWidgets import (QApplication, QCheckBox, QDialog, QFormLayout,
                               QLabel, QLineEdit, QMainWindow, QMenu,
                               QMessageBox, QPushButton, QSystemTrayIcon)
import cpuinfo
import psutil
warnings.filterwarnings("ignore")


class I8kGui(QMainWindow):

    def __init__(self):
        super(I8kGui, self).__init__()
        self.settings = QSettings()
        self.critical_error = False
        self.degree_sign = u'\N{DEGREE SIGN}'
        self.use_cpu_ave_freq = False
        self.p_state = None
        self.p = None
        self.smbios_data = []
        self.smbios_info = {}
        self.supported_thermal_modes_data = []
        self.supported_thermal_modes = []
        self.current_thermal_mode_data = []
        self.current_thermal_mode = None
        self.always_on = False
        self.bios_thermal_control_on = False
        self.tray_menu = QMenu()
        self.thermal_menu_group = QActionGroup(self.tray_menu)
        self.thermal_control_menu = QMenu("I8K Thermal Management")
        self.monitor_interval = 1000
        self.always_on_checkbox = QCheckBox()
        self.thermal_checkbox = QCheckBox()
        self.cpu_ave_freq_checkbox = QCheckBox()
        self.interval_input = QLineEdit()
        self.settings_dialog = QDialog()
        self.info_dialog = QDialog()
        self.save_button = QPushButton("Save", self.settings_dialog)
        self.smbios_button = QPushButton("SMBIOS Information",
                                         self.info_dialog)
        self.cpu_model = QLabel(cpuinfo.get_cpu_info()['brand_raw'])
        self.cpu_tdp = QLabel("N/A")
        self.i8k_format_version = QLabel("1")
        self.bios_version = QLabel("1")
        self.service_tag = QLabel("N/A")
        self.power_status = QLabel("N/A")
        self.button_status = QLabel("N/A")
        self.fan_mode_menu_item = QAction("")
        self.fan_mode_menu_item.setCheckable(False)
        self.left_fan_thermal_menu_item = QAction("")
        self.left_fan_thermal_menu_item.setCheckable(False)
        self.right_fan_thermal_menu_item = QAction("")
        self.right_fan_thermal_menu_item.setCheckable(False)
        self.left_fan_mode = 0
        self.right_fan_mode = 0
        self.i8k_info = {}
        self.load_settings()
        self.monitorTimer = QTimer(self)
        self.monitorTimer.timeout.connect(self.refresh_monitor)
        self.monitorTimer.setInterval(self.monitor_interval)
        self.create_settings_dialog()
        self.create_info_dialog()
        self.tray = None
        self.first_load = True
        self.cpu_mhz = QAction("CPU MHz:                ")
        self.cpu_details = QMenu("Per CPU Core                ")
        self.cpu_freq_list = []
        self.cpu_curr_freqs = []
        self.cpu_num = psutil.cpu_count()
        self.build_cpu_menu()
        self.cpu_governor = QAction("CPU Governor:               ")
        self.cpu_temp = QAction("CPU Temp:                ")
        self.left_fan_rpm = QAction("Left Fan RPM:          ")
        self.right_fan_rpm = QAction("Right Fan RPM:       ")
        self.left_fan_status = QAction("Left Fan Mode:       ")
        self.right_fan_status = QAction("Right Fan Mode:    ")
        self.ac_power_supply_on = None
        self.load_sys_tray()

    def close_app(self):
        self.save_settings()
        app.quit()

    def thermal_error_dialog(self, cmd='disable',
                             msg="Critical Service Error. "
                             "Please enter your password."):
        error_dialog = QMessageBox(QMessageBox.Icon.Critical, "i8kgui", msg)
        error_dialog.setText(msg)
        button = error_dialog.exec()
        if button == QMessageBox.Ok:
            self.bios_thermal_control(op=cmd)

    def load_settings(self):
        # load continuous data collection setting
        always_on = str(self.settings.value('always_on'))
        if always_on and always_on.lower() == 'false':
            self.always_on = False
            self.always_on_checkbox.setCheckState(Qt.Unchecked)
        else:
            self.always_on = True
            self.always_on_checkbox.setCheckState(Qt.Checked)
        # load monitoring interval setting
        self.monitor_interval = int(str(self.settings.value('interval', 1000)))

        # load average CPU freq. setting
        use_cpu_ave_freq = str(self.settings.value('use_cpu_ave_freq'))
        if use_cpu_ave_freq and use_cpu_ave_freq.lower() == 'true':
            self.use_cpu_ave_freq = True
            self.cpu_ave_freq_checkbox.setCheckState(Qt.Checked)
        else:
            self.use_cpu_ave_freq = False
            self.cpu_ave_freq_checkbox.setCheckState(Qt.Unchecked)
        # load smbios information from config
        info = list(self.settings.value('smbios', []))
        if info:
            # reconstruct list back into dict preserving order
            self.smbios_info = {
                info[i][0]: info[i][1]
                for i in range(0, len(info))
            }
            self.smbios_button.setDisabled(True)
        # load bios thermal mode setting
        bios_thermal_control_on = str(self.settings.value(
            'bios_thermal_control_on'))

        # load current mode
        self.current_thermal_mode = self.settings.value('current_thermal_mode')
        # load supported thermal modes setting
        supported_thermal_modes = self.settings.value(
            'supported_thermal_modes')
        # setup bios thermal mode setting
        if bios_thermal_control_on is None:
            self.bios_thermal_control_on = False
        elif bios_thermal_control_on.lower() == 'true':
            self.bios_thermal_control_on = True
        elif bios_thermal_control_on.lower() == 'false':
            self.bios_thermal_control_on = False
        if supported_thermal_modes is None:
            self.supported_thermal_modes = []
        else:
            self.supported_thermal_modes = list(supported_thermal_modes)
        # check current status of i8kmon services.
        i8k_is_active = self.check_thermal_control()
        # set system to last known settings or default
        if not self.bios_thermal_control_on and not i8k_is_active:
            self.thermal_error_dialog(cmd='disable')
        elif self.bios_thermal_control_on and i8k_is_active:
            self.thermal_error_dialog(cmd='enable')
        if self.bios_thermal_control_on:
            self.thermal_checkbox.setChecked(True)
        else:
            self.thermal_checkbox.setChecked(False)

    def save_settings(self):
        self.settings.setValue('current_thermal_mode',
                               self.current_thermal_mode)
        self.settings.setValue('supported_thermal_modes',
                               self.supported_thermal_modes)
        self.settings.setValue('bios_thermal_control_on',
                               self.bios_thermal_control_on)
        self.settings.setValue('always_on', self.always_on)
        self.settings.setValue('use_cpu_ave_freq', self.use_cpu_ave_freq)
        self.settings.setValue('interval', self.monitor_interval)
        if self.smbios_info:
            # preserve ordering by storing a list
            self.settings.setValue('smbios', list(self.smbios_info.items()))

    def enable_thermal_control(self, checked):
        if checked == Qt.Checked:
            self.bios_thermal_control(op='enable')
        else:
            self.bios_thermal_control(op='disable')

    def always_collect(self, checked):
        if checked == Qt.Checked:
            self.monitor_interval = int(self.interval_input.text())
            self.monitorTimer.setInterval(self.monitor_interval)
            self.always_on = True
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()
            self.monitorTimer.start()
        else:
            self.always_on = False
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()

    def enable_ave_cpu_freq(self, checked):
        self.use_cpu_ave_freq = checked == Qt.Checked

    def save_dialog_settings(self):
        if self.monitor_interval != int(self.interval_input.text()):
            self.monitor_interval = int(self.interval_input.text())
            self.monitorTimer.setInterval(self.monitor_interval)
            if self.monitorTimer.isActive():
                self.monitorTimer.stop()
                self.monitorTimer.start()
        self.save_settings()
        self.settings_dialog.close()

    def close_info_dialog(self):
        self.save_settings()
        self.info_dialog.close()

    def smbios_message(self, msg):
        split_msg = msg.split(': ')
        for item in split_msg:
            split_item = item.split('\n')
            for part_item in split_item:
                self.smbios_data.append(part_item.strip())

    def check_thermal_control(self):
        if self.p is not None:
            return
        active_services = []
        # check service files are available
        dell_service_file = Path(
            '/etc/systemd/system/dell-bios-fan-control.service')
        if not dell_service_file.is_file():
            print(
                "Error systemctl dell-bios-fan-control.service not found")
            return False
        i8k_service_file = Path('/lib/systemd/system/i8kmon.service')
        if not i8k_service_file.is_file():
            print("Error systemctl i8kmon.service not found")
            return False
        # check which system services are active.
        # keep a reference to the QProcess (e.g. on self)
        # while it's running.
        self.p = QProcess()
        self.p.start("systemctl", ['is-active', 'i8kmon.service'])
        self.p.waitForFinished()
        result = self.p.readLine()
        output = bytes(result).decode("utf8")
        is_active = output.strip('\n')
        if is_active == "active":
            active_services.append(True)
        self.p.close()
        self.p = None
        # keep a reference to the QProcess (e.g. on self)
        # while it's running.
        self.p = QProcess()
        self.p.start("systemctl",
                     ['is-active', 'dell-bios-fan-control.service'])
        self.p.waitForFinished()
        result = self.p.readLine()
        output = bytes(result).decode("utf8")
        is_active = output.strip('\n')
        self.p.close()
        self.p = None
        if is_active == "active":
            active_services.append(True)
        # i8kmon requires 2 services active, or
        # no services active (BIOS mode). Any other
        # combination is a fail.
        return len(active_services) == 2

    def bios_thermal_control(self, op=None):
        if self.p is not None:
            return False
        # find smbios script
        thermal_file = Path(str(shutil.which("i8kgui_thermal_control")))
        if not thermal_file.is_file():
            thermal_file = Path("i8kgui_thermal_control")
        if op == 'enable':
            # Keep a reference to the QProcess (e.g. on self)
            # while it's running.
            self.p = QProcess()
            self.p.readyReadStandardOutput.connect(
                self.handle_thermal_stdout)
            self.p.readyReadStandardError.connect(
                self.handle_thermal_stderr)
            self.p.stateChanged.connect(self.handle_process_state)
            # Clean up once complete.
            self.p.finished.connect(self.thermal_process_finished)
            self.p.start("pkexec",
                         [str(thermal_file.resolve()), '--enable'])
        elif op == 'disable':
            # Keep a reference to the QProcess (e.g. on self)
            # while it's running.
            self.p = QProcess()
            self.p.readyReadStandardOutput.connect(
                self.handle_thermal_stdout)
            self.p.readyReadStandardError.connect(
                self.handle_thermal_stderr)
            self.p.stateChanged.connect(self.handle_process_state)
            # Clean up once complete.
            self.p.finished.connect(self.thermal_process_disable_finished)
            self.p.start("pkexec",
                         [str(thermal_file.resolve()), '--disable'])

    def handle_thermal_stderr(self):
        if self.p:
            data = self.p.readAllStandardError()
            stderr = bytes(data).decode("utf8")
            # check if pkexec passwd input cancelled
            if 'Request dismissed' in stderr:
                self.p.finished.emit(1, QProcess.CrashExit)
            else:
                print(f"Error: handle_thermal_stderr {stderr}")

    def handle_thermal_stdout(self):
        if not self.p:
            return

        data = self.p.readAllStandardOutput()
        stdout = bytes(data).decode("utf8")
        if stdout.startswith('Supported Thermal Modes'):
            split_stdout = stdout.split('\n')
            for item in split_stdout:
                self.supported_thermal_modes_data.append(item.strip())
        elif stdout.startswith('Current Thermal Modes'):
            split_stdout = stdout.split('\n')
            for item in split_stdout:
                self.current_thermal_mode_data.append(item.strip())
        elif stdout.startswith('Helper function to Set Thermal Mode'):
            split_stdout = stdout.split(': ')
            self.current_thermal_mode = split_stdout[1].strip().title(
            ).replace("-", " ")

    def close_process(self):
        if self.p and self.p.state() != 0:
            self.p.close()
        self.p = None

    def kill_process(self):
        try:
            if self.p:
                self.p.terminate()
                self.p.waitForFinished(1000)
                self.p.kill()
        except Exception:
            pass
        self.p = None

    def thermal_selection_finished(self):
        # bios mode change
        if self.p and self.p.exitCode() != 0:
            self.kill_process()
            return
        else:
            self.close_process()
            self.update_thermal_modes()

    def thermal_process_finished(self):
        # switch between i8k and bios modes
        if self.p and self.p.exitCode() != 0:
            self.kill_process()
            self.thermal_checkbox.setChecked(False)
            self.bios_thermal_control_on = False
            self.supported_thermal_modes_data = []
            self.current_thermal_mode_data = []
            return
        else:
            self.close_process()
            self.update_thermal_modes()

    def thermal_process_disable_finished(self):
        if self.p and self.p.exitCode() != 0:
            self.kill_process()
            self.thermal_checkbox.setChecked(True)
            self.bios_thermal_control_on = True
            self.supported_thermal_modes_data = []
            self.current_thermal_mode_data = []
            return
        else:
            self.close_process()
            self.update_thermal_modes()

    def update_thermal_modes(self):
        if self.supported_thermal_modes_data:
            if "Supported Thermal Modes:" in self.supported_thermal_modes_data:
                self.supported_thermal_modes_data.remove(
                    "Supported Thermal Modes:")
            if "" in self.supported_thermal_modes_data:
                self.supported_thermal_modes_data.remove("")
            self.supported_thermal_modes = self.supported_thermal_modes_data
            self.supported_thermal_modes_data = []

        if self.current_thermal_mode_data:
            if "Current Thermal Modes:" in self.current_thermal_mode_data:
                self.current_thermal_mode_data.remove("Current Thermal Modes:")
            self.current_thermal_mode = self.current_thermal_mode_data[
                0].title().replace("-", " ")
            self.current_thermal_mode_data = []
        # debug
        # print(f"disable supported modes: {self.supported_thermal_modes}")
        # print(f"disable current mode {self.current_thermal_mode}")
        self.bios_thermal_control_on = bool(self.thermal_checkbox.isChecked(
        ) and self.current_thermal_mode is not None)
        self.switch_thermal_menu()

    def switch_thermal_menu(self):
        # remove and re-build thermal menu
        self.remove_thermal_menu()
        self.build_thermal_menu()

    def remove_thermal_menu(self):
        actions = self.thermal_menu_group.actions()
        for action in actions:
            self.thermal_control_menu.removeAction(action)
            self.thermal_menu_group.removeAction(action)
        self.thermal_menu_group.setEnabled(False)

    def build_thermal_menu(self):
        if self.thermal_menu_group.actions():
            return
        if self.bios_thermal_control_on:
            if self.supported_thermal_modes:
                for item in self.supported_thermal_modes:
                    thermal_menu_item = QAction(item)
                    thermal_menu_item.setCheckable(True)
                    self.thermal_control_menu.addAction(thermal_menu_item)
                    self.thermal_menu_group.addAction(thermal_menu_item)
                self.thermal_menu_group.setEnabled(True)
                self.thermal_control_menu.setTitle("BIOS Thermal Management")
                actions = self.thermal_menu_group.actions()
                for action in actions:
                    if action.text() == self.current_thermal_mode:
                        action.setChecked(True)
        else:
            self.i8k_info = self.get_i8k_information()
            if self.i8k_info:
                for key, value in self.i8k_info.items():
                    if key.startswith('Fan Mode'):
                        mode = key.split('Fan Mode ')
                        if int(mode[1]) == self.left_fan_mode:
                            if self.ac_power_supply_on:
                                title = (
                                    f"{key}: Low: {value[0]}{self.degree_sign}C  "
                                    f"High: {value[1]}{self.degree_sign}C")
                            else:
                                title = (
                                    f"{key}: Low: {value[2]}{self.degree_sign}C  "
                                    f"High: {value[3]}{self.degree_sign}C")
                            self.fan_mode_menu_item.setText(title)
                            self.thermal_control_menu.addAction(self.fan_mode_menu_item)
                            self.thermal_menu_group.addAction(self.fan_mode_menu_item)
                    elif key.startswith('Left Speed'):
                        title = f"Max {key}: {value[self.left_fan_mode]}"
                        self.left_fan_thermal_menu_item.setText(title)
                        self.thermal_control_menu.addAction(self.left_fan_thermal_menu_item)
                        self.thermal_menu_group.addAction(self.left_fan_thermal_menu_item)
                    elif key.startswith('Right Speed'):
                        title = f"Max {key}: {value[self.right_fan_mode]}"
                        self.right_fan_thermal_menu_item.setText(title)
                        self.thermal_control_menu.addAction(self.right_fan_thermal_menu_item)
                        self.thermal_menu_group.addAction(self.right_fan_thermal_menu_item)
                    else:
                        title = f"{key}: {value}{self.degree_sign}C"
                        thermal_menu_item = QAction(title)
                        thermal_menu_item.setCheckable(False)
                        self.thermal_control_menu.addAction(thermal_menu_item)
                        self.thermal_menu_group.addAction(thermal_menu_item)
            self.thermal_menu_group.setEnabled(True)
            self.thermal_control_menu.setTitle(
                "I8K Thermal Management")

    def build_cpu_menu(self):
        for i in range(self.cpu_num):
            self.cpu_curr_freqs.append(
                f"/sys/devices/system/cpu/cpu{i}/cpufreq/scaling_cur_freq")
            c_action = QAction(f"CPU {i}")
            c_action.setCheckable(False)
            self.cpu_details.addAction(c_action)
            self.cpu_freq_list.append(c_action)

    def get_cpu_tdp(self):
        tdp = Path(
            "/sys/devices/virtual/powercap/intel-rapl/intel-rapl:0/constraint_0_max_power_uw"
        ).resolve()
        if tdp.is_file():
            with tdp.open('r') as f:
                self.cpu_tdp.setText(f"{int(f.read().strip()) // 1000000} W")
        return self.cpu_tdp

    def get_i8k_information(self):
        if self.critical_error:
            return
        info = {}
        i8k_config = None
        try:
            i8kmon_conf = Path("/etc/i8kmon.conf").resolve()
            if i8kmon_conf.is_file():
                i8k_config = open(i8kmon_conf, 'r')
        except IOError as e:
            self.critical_error = True
            if self.tray:
                self.tray.showMessage("i8kgui",
                                      f"Error cannot find /etc/i8kmon.conf. "
                                      f"Please check your config file \n\n{e}",
                                      icon=QSystemTrayIcon.Critical,
                                      msecs=10000)
        else:
            if i8k_config:
                for line in i8k_config:
                    if line.startswith('set config(t_high)'):
                        conf = line.split('set config(t_high)')[1].strip()
                        info['High CPU Temp'] = conf
                    if line.startswith('set config(0)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 0'] = list(conf[1].split())
                    if line.startswith('set config(1)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 1'] = list(conf[1].split())
                    if line.startswith('set config(2)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 2'] = list(conf[1].split())
                    if line.startswith('set config(3)'):
                        split_line = line.split('{')
                        conf = split_line[2].split('}')
                        info['Fan Mode 3'] = list(conf[1].split())
                    if line.startswith('set status(leftspeed)'):
                        conf = line.split(
                            "set status(leftspeed)")[1].strip().strip('"')
                        info['Left Speed'] = list(conf.split())
                    if line.startswith('set status(rightspeed)'):
                        conf = line.split(
                            "set status(rightspeed)")[1].strip().strip('"')
                        info['Right Speed'] = list(conf.split())
                i8k_config.close()
        return info

    def get_smbios_information(self):
        if self.p is not None:
            return

        # find smbios script
        smbios_file = Path(str(shutil.which("smbios-sys-info")))
        if not smbios_file.is_file():
            if self.tray:
                self.tray.showMessage(
                    "i8kgui",
                    "Error please install python3-libsmbios, "
                    "smbios-sys-info not found",
                    icon=QSystemTrayIcon.Critical,
                    msecs=10000)
                return
            # self.smbios_message("Executing process")
            # Keep a reference to the QProcess (e.g. on self)
            # while it's running.
            self.p = QProcess()
            self.p.readyReadStandardOutput.connect(self.handle_smbios_stdout)
            self.p.readyReadStandardError.connect(self.handle_smbios_stderr)
            self.p.stateChanged.connect(self.handle_process_state)
            # Clean up once complete.
            self.p.finished.connect(self.smbios_process_finished)
            self.p.start("pkexec", [str(smbios_file.resolve())])

    def handle_smbios_stderr(self):
        if self.p:
            data = self.p.readAllStandardError()
            stderr = bytes(data).decode("utf8")
            if 'Request dismissed' in stderr:
                self.p.finished.emit(1, QProcess.CrashExit)
            else:
                print(f"Error: handle_smbios_stderr {stderr}")

    def handle_smbios_stdout(self):
        if self.p:
            data = self.p.readAllStandardOutput()
            stdout = bytes(data).decode("utf8")
            self.smbios_message(stdout)

    def handle_process_state(self, state):
        states = {
            QProcess.NotRunning: 'NotRunning',
            QProcess.Starting: 'Starting',
            QProcess.Running: 'Running',
        }
        self.p_state = states[state]

    def smbios_process_finished(self):
        if self.p and self.p.exitCode() != 0:
            self.kill_process()
        else:
            self.close_process()
            self.process_smbios_data()

    def process_smbios_data(self):
        if self.smbios_data:
            self.smbios_data.pop()  # remove white space
            self.smbios_info = {
                self.smbios_data[i]: self.smbios_data[i + 1]
                for i in range(0, len(self.smbios_data), 2)
            }  # convert data to dict
            self.smbios_data = []  # empty data container
            f_layout = self.info_dialog.layout()
            for key, value in self.smbios_info.items():
                f_layout.insertRow(f_layout.rowCount() - 2, str(key),
                                   QLabel(str(value)))
            self.smbios_button.setDisabled(True)

    def create_info_dialog(self):
        close_button = QPushButton("close", self.info_dialog)
        close_button.setMaximumWidth(100)
        close_button.clicked.connect(self.close_info_dialog)

        self.smbios_button.setMaximumWidth(250)
        self.smbios_button.clicked.connect(self.get_smbios_information)

        f_layout = QFormLayout()
        f_layout.addRow("CPU Model", self.cpu_model)
        f_layout.addRow("CPU TDP", self.get_cpu_tdp())
        f_layout.addRow("i8k Format Version", self.i8k_format_version)
        f_layout.addRow("BIOS Version", self.bios_version)
        f_layout.addRow("Service Tag", self.service_tag)
        f_layout.addRow("A/C Power Supply", self.power_status)
        f_layout.addRow("Button Status", self.button_status)
        f_layout.addRow(" ", None)
        f_layout.addRow("(requires password)", self.smbios_button)
        f_layout.addRow(" ", None)
        f_layout.addRow(" ", None)
        f_layout.addWidget(close_button)
        if self.smbios_info:
            for key, value in self.smbios_info.items():
                f_layout.insertRow(f_layout.rowCount() - 2, str(key),
                                   QLabel(str(value)))
        self.info_dialog.setLayout(f_layout)
        # set dialog geometry
        self.info_dialog.setWindowTitle("Information")
        self.info_dialog.setWindowModality(QtCore.Qt.ApplicationModal)
        self.info_dialog.setMinimumWidth(450)
        self.info_dialog.setMaximumWidth(600)
        self.info_dialog.setMaximumHeight(600)
        center_point = QScreen.availableGeometry(
            QApplication.primaryScreen()).center()
        fg = self.info_dialog.frameGeometry()
        fg.moveCenter(center_point)
        self.info_dialog.move(fg.topLeft())

    def create_settings_dialog(self):
        self.save_button.setMaximumWidth(100)

        self.always_on_checkbox.setText("Collect statistics continuously")
        self.always_on_checkbox.stateChanged.connect(self.always_collect)

        self.thermal_checkbox.setText("Enable BIOS thermal management")
        self.thermal_checkbox.stateChanged.connect(self.enable_thermal_control)

        self.cpu_ave_freq_checkbox.setText("Display average CPU freq.")
        self.cpu_ave_freq_checkbox.stateChanged.connect(
            self.enable_ave_cpu_freq)

        self.interval_input.setValidator(QIntValidator())
        self.interval_input.setMaxLength(6)
        self.interval_input.setText(str(self.monitor_interval))

        self.save_button.clicked.connect(self.save_dialog_settings)
        f_layout = QFormLayout()
        f_layout.addRow("(requires password)", self.thermal_checkbox)
        f_layout.addRow(" ", self.always_on_checkbox)
        f_layout.addRow(" ", self.cpu_ave_freq_checkbox)
        f_layout.addRow(" ", None)
        f_layout.addRow("Monitoring Interval (milliseconds):",
                        self.interval_input)
        f_layout.addRow(" ", None)
        f_layout.addRow(self.save_button)
        self.settings_dialog.setLayout(f_layout)
        # set dialog geometry
        self.settings_dialog.setWindowTitle("Settings")
        self.settings_dialog.setWindowModality(QtCore.Qt.ApplicationModal)
        self.settings_dialog.setMaximumWidth(400)
        self.settings_dialog.setMaximumHeight(400)
        center_point = QScreen.availableGeometry(
            QApplication.primaryScreen()).center()
        fg = self.settings_dialog.frameGeometry()
        fg.moveCenter(center_point)
        self.settings_dialog.move(fg.topLeft())

    def load_sys_tray(self):
        self.tray = QSystemTrayIcon(self)
        if self.tray.isSystemTrayAvailable():
            icon = QIcon(
                f'{str(Path.home())}/.local/share/icons/i8kgui_icon.png')
            if icon.pixmap(QSize(64, 64)).isNull():
                icon = QIcon('icons/i8kgui_icon.png')
            self.tray.setIcon(icon)
            self.tray.activated.connect(self.status)
            self.tray.messageClicked.connect(self.message_clicked)
            # workaround because tray activated only works with double click
            self.tray_menu.aboutToShow.connect(self.monitor)
            self.tray_menu.aboutToHide.connect(self.stop_monitor)
            # setup display
            self.tray_menu.addAction(self.cpu_mhz)
            self.tray_menu.addAction(self.cpu_governor)
            self.connect_cpupower()
            self.tray_menu.addAction(self.cpu_temp)
            self.tray_menu.addMenu(self.cpu_details)
            self.tray_menu.addAction(self.left_fan_rpm)
            self.tray_menu.addAction(self.right_fan_rpm)
            self.tray_menu.addAction(self.left_fan_status)
            self.tray_menu.addAction(self.right_fan_status)
            self.tray_menu.addSeparator()
            # setup thermal control management menu
            self.tray_menu.addMenu(self.thermal_control_menu)
            self.thermal_menu_group.setExclusive(True)
            self.thermal_menu_group.triggered.connect(
                self.thermal_mode_selection)
            self.build_thermal_menu()  # menu created based on settings
            self.tray_menu.addSeparator()
            # add info, settings and quit menu items
            action_info = self.tray_menu.addAction("Information")
            action_info.triggered.connect(self.show_info)
            action_settings = self.tray_menu.addAction("Settings")
            action_settings.triggered.connect(self.show_settings)
            action_quit = self.tray_menu.addAction("Quit")
            action_quit.triggered.connect(self.close_app)

            self.tray.setContextMenu(self.tray_menu)
            self.tray.setToolTip("i8kgui")
            self.tray.setVisible(True)
        else:
            QMessageBox.critical(
                None, "i8kgui", "Unable to locate system tray on this system.")
            self.close_app()

    def connect_cpupower(self):
        # connect to cpupower-gui if found
        cpupower_file = Path(str(shutil.which("cpupower-gui")))
        if cpupower_file.is_file():
            self.cpu_governor.triggered.connect(self.show_cpupower)

    def show_cpupower(self):
        self.cpupower = QProcess()
        self.cpupower.start("cpupower-gui")
        self.cpupower.waitForFinished()
        result = self.cpupower.readLine()
        output = bytes(result).decode("utf8")
        if error := output.strip('\n'):
            print(f"Error: failed to load cpupower-gui {error}")
        self.cpupower.close()
        self.cpupower = None

    def thermal_mode_selection(self, checked):
        if self.bios_thermal_control_on:
            if self.p is None:
                # find libsmbios script
                thermal_file = Path(str(shutil.which("smbios-thermal-ctl")))
                if not thermal_file.is_file():
                    if self.tray:
                        self.tray.showMessage(
                            "i8kgui",
                            "Error please install python3-libsmbios, "
                            "smbios-thermal-ctl not found.",
                            icon=QSystemTrayIcon.Critical,
                            msecs=10000)
                    return
                t_args = "--set-thermal-mode="
                if checked.text() == 'Quiet':
                    t_args = t_args + "quiet"
                elif checked.text() == 'Cool Bottom':
                    t_args = t_args + "cool-bottom"
                elif checked.text() == 'Balanced':
                    t_args = t_args + "balanced"
                elif checked.text() == 'Performance':
                    t_args = t_args + "performance"
                else:
                    t_args = t_args + 'balanced'
                # Keep a reference to the QProcess (e.g. on self)
                # while it's running.
                self.p = QProcess()
                self.p.readyReadStandardOutput.connect(
                    self.handle_thermal_stdout)
                self.p.readyReadStandardError.connect(
                    self.handle_thermal_stderr)
                self.p.stateChanged.connect(self.handle_process_state)
                # Clean up once complete.
                self.p.finished.connect(self.thermal_selection_finished)
                self.p.start("pkexec", [str(thermal_file.resolve()), t_args])
        else:
            print("Edit i8kmon config")  # TODO - add i8kmon config updating

    @Slot()
    def message_clicked(self):
        self.close_app()

    def read_i8kmon_info(self):
        i8k_proc = None
        try:
            i8kmon_proc = Path("/proc/i8k").resolve()
            if i8kmon_proc.is_file():
                i8k_proc = open(i8kmon_proc, 'r')
        except IOError as e:
            self.critical_error = True
            if self.tray:
                self.tray.showMessage("i8kgui",
                                      f"Error cannot find i8k module. "
                                      f"Please install/start i8kutils.\n\n{e}",
                                      icon=QSystemTrayIcon.Critical,
                                      msecs=10000)
        else:
            if i8k_proc:
                line = i8k_proc.readline()  # output is only a single line.
                i8k_proc.close()
                split_line = line.split(' ')
                self.cpu_temp.setText(f"CPU Temp:                "
                                      f"{split_line[3].strip()}"
                                      f"{self.degree_sign}C")
                self.left_fan_rpm.setText(
                    f"Left Fan RPM:          {split_line[6].strip()}")
                self.right_fan_rpm.setText(
                    f"Right Fan RPM:       {split_line[7].strip()}")
                self.left_fan_status.setText(
                    f"Left Fan Mode:       {split_line[4].strip()}")
                self.right_fan_status.setText(
                    f"Right Fan Mode:    {split_line[5].strip()}")
                if self.left_fan_mode != int(
                        split_line[4].strip()) or self.right_fan_mode != int(
                            split_line[5].strip()):
                    self.left_fan_mode = int(split_line[4].strip())
                    self.right_fan_mode = int(split_line[5].strip())
                    self.update_i8k_thermal()
                self.update_i8k_ac_power()

                self.i8k_format_version.setText(split_line[0].strip())
                self.bios_version.setText(split_line[1].strip())
                self.service_tag.setText(split_line[2].strip())
                self.power_status.setText(split_line[8].strip())
                self.button_status.setText(split_line[9].strip())

    def read_cpu_info(self):
        # gather current CPU MHz.
        try:
            cpu_procs = []
            all_mhz = []
            for cpu in self.cpu_curr_freqs:
                cpu_proc = Path(cpu).resolve()
                if cpu_proc.is_file():
                    proc = open(cpu_proc, 'r')
                    cpu_procs.append(proc)
                    for line in proc:
                        mhz = int(line.strip('\n')) // 1000
                        all_mhz.append(mhz)
        except IOError as e:
            self.critical_error = True
            if self.tray:
                self.tray.showMessage(
                    "i8kgui",
                    f"Error cannot find /proc/cpuinfo.\n\n{e}",
                    icon=QSystemTrayIcon.Critical,
                    msecs=10000)
        else:
            if self.use_cpu_ave_freq:
                total_mhz = sum(all_mhz)
                mhz = total_mhz // len(all_mhz)
            else:
                all_mhz.sort()
                mhz = all_mhz[-1]
            self.cpu_mhz.setText(
                f"CPU Freq:                  {mhz} MHz")
            for i, c in enumerate(self.cpu_freq_list):
                c.setText(f"CPU {i}:\t   {all_mhz[i]} MHz\t     "
                          f"{psutil.sensors_temperatures()['coretemp'][i+1][1]}"
                          f"{self.degree_sign}C")
            for cpu in cpu_procs:
                cpu.close()

    def read_cpu_gov_info(self):
        # gather current CPU governor
        gov_sys = None
        try:
            scaling_sysfs = Path(
                "/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"
            ).resolve()
            if scaling_sysfs.is_file:
                gov_sys = open(scaling_sysfs, 'r')
        except IOError as e:
            self.critical_error = True
            if self.tray:
                self.tray.showMessage(
                    "i8kgui",
                    f"Error cannot find "
                    f"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor."
                    f"\n\n{e}",
                    icon=QSystemTrayIcon.Critical,
                    msecs=10000)
        else:
            if gov_sys:
                gov = gov_sys.readline().strip()
                gov_sys.close()
                self.cpu_governor.setText(
                    f"CPU Governor:        {gov.capitalize()}")

    def read_power_supply_status(self):
        # gather power supply status
        pwr_sys = None
        try:
            power_sysfs = Path("/sys/class/power_supply/AC/online").resolve()
            if power_sysfs.is_file():
                pwr_sys = open(power_sysfs, 'r')
        except IOError as e:
            self.critical_error = True
            if self.tray:
                self.tray.showMessage(
                    "i8kgui",
                    f"Error cannot find /sys/class/power_supply/AC/online."
                    f"\n\n{e}",
                    icon=QSystemTrayIcon.Critical,
                    msecs=10000)
        else:
            if pwr_sys:
                pwr_ac = pwr_sys.readline().strip()
                pwr_sys.close()
                self.ac_power_supply_on = int(pwr_ac) == 1

    def read_proc(self):
        # read i8k, CPU and power values then update the system tray
        # and send a fake click to initiate live updating while
        # the system tray is in active use.
        if self.critical_error:
            return
        self.read_i8kmon_info()
        self.read_cpu_info()
        self.read_cpu_gov_info()
        self.read_power_supply_status()
        # send fake single-click event as workaround
        if self.tray:
            self.tray.activated.emit(QSystemTrayIcon.Trigger)

    def update_i8k_ac_power(self):
        # update i8k thermal menu fan mode based on A/C power supply status
        if not self.i8k_info:
            return
        for key, value in self.i8k_info.items():
            if key.startswith('Fan Mode'):
                mode = key.split('Fan Mode ')
                if int(mode[1]) == self.left_fan_mode:
                    if self.ac_power_supply_on:
                        title = (f"{key}: Low: "
                                 f"{value[0]}{self.degree_sign}C  "
                                 f"High: {value[1]}{self.degree_sign}C")
                    else:
                        title = (f"{key}: Low: "
                                 f"{value[2]}{self.degree_sign}C  "
                                 f"High: {value[3]}{self.degree_sign}C")
                    self.fan_mode_menu_item.setText(title)
                    break

    def update_i8k_thermal(self):
        # update i8k thermal menu. Activated when i8k changes fan mode.
        if not self.i8k_info:
            self.i8k_info = self.get_i8k_information()
        if self.i8k_info:
            for key, value in self.i8k_info.items():
                if key.startswith('Fan Mode'):
                    mode = key.split('Fan Mode ')
                    if int(mode[1]) == self.left_fan_mode:
                        if self.ac_power_supply_on:
                            title = (f"{key}: Low: "
                                     f"{value[0]}{self.degree_sign}C  "
                                     f"High: {value[1]}{self.degree_sign}C")
                        else:
                            title = (f"{key}: Low: "
                                     f"{value[2]}{self.degree_sign}C  "
                                     f"High: {value[3]}{self.degree_sign}C")
                        self.fan_mode_menu_item.setText(title)
                elif key.startswith('Left Speed'):
                    title = f"Max {key}: {value[self.left_fan_mode]}"
                    self.left_fan_thermal_menu_item.setText(title)
                elif key.startswith('Right Speed'):
                    title = f"Max {key}: {value[self.right_fan_mode]}"
                    self.right_fan_thermal_menu_item.setText(title)

    def status(self, reason):
        # start live updating of values if system tray is in active use,
        # and employ workaround for timer being started upon load.
        if reason == QSystemTrayIcon.ActivationReason.Trigger:
            if not self.monitorTimer.isActive():
                if not self.first_load:
                    self.monitorTimer.start()
                else:
                    # workaround to not start QTimer
                    # when tray is loaded first time
                    self.first_load = False

    def monitor(self):
        self.read_proc()

    def refresh_monitor(self):
        self.read_proc()

    def stop_monitor(self):
        if not self.always_on and self.monitorTimer.isActive():
            self.monitorTimer.stop()

    def show_settings(self):
        if not self.settings_dialog.isVisible():
            self.settings_dialog.show()
        self.settings_dialog.raise_()
        self.settings_dialog.setFocus()

    def show_info(self):
        if not self.info_dialog.isVisible():
            self.info_dialog.show()
        self.info_dialog.raise_()
        self.info_dialog.setFocus()


if __name__ == '__main__':
    app = QApplication([])
    app.setOrganizationName("i8kgui")
    app.setApplicationName("i8kgui")
    app.setApplicationVersion("0.4")
    # setup Dark Mode QPalette - initial setup
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Light, QColor(68, 68, 68))
    palette.setColor(QPalette.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ToolTipBase, Qt.white)
    palette.setColor(QPalette.ToolTipText, Qt.black)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218, 192))
    palette.setColor(QPalette.HighlightedText, Qt.white)
    # setup Dark Mode disabled QPalette
    palette.setColor(QPalette.Disabled, QPalette.Window, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.WindowText,
                     QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.Base, QColor(68, 68, 68))
    palette.setColor(QPalette.Disabled, QPalette.Text,
                     QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.Button,
                     QColor(53, 53, 53, 128))
    palette.setColor(QPalette.Disabled, QPalette.ButtonText,
                     QColor(255, 255, 255, 128))
    palette.setColor(QPalette.Disabled, QPalette.BrightText, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.Link, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.Highlight, Qt.black)
    palette.setColor(QPalette.Disabled, QPalette.HighlightedText, Qt.black)
    # add Dark Mode to i8kgui
    app.setPalette(palette)

    app.setQuitOnLastWindowClosed(False)
    tray = I8kGui()

    app.exec()
